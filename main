import os
import re
import sys
import json
from pathlib import Path
from typing import List, Tuple, Optional

import tkinter as tk
from tkinter import ttk, filedialog, messagebox

import pandas as pd
import numpy as np
import matplotlib
matplotlib.use("Agg")  # headless backend for saving PDFs
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages
from matplotlib.patches import Rectangle

APP_TITLE = "Neb Label Printer"

# Defaults
DEFAULT_LABEL_W_IN = 2.0
DEFAULT_LABEL_H_IN = 1.0
DEFAULT_TITLE = "Neb Label"
DEFAULT_TITLE_COLOR = "#1e6fff"  # blue
DEFAULT_MARGIN_PCT = 7           # outer margins as % of figure
DEFAULT_TEXT_SCALE_PCT = 100     # text scale percent (100% = baseline)
PLOT_DPI = 300


def default_settings_path() -> Path:
    if sys.platform.startswith("win"):
        base = Path(os.getenv("LOCALAPPDATA", Path.home()))
        return base / "NebLabelPrinter" / "settings.json"
    else:
        return Path.home() / ".neb_label_printer.json"


def read_excel_sheet_names(xlsx_path: str) -> List[str]:
    xl = pd.ExcelFile(xlsx_path)
    try:
        return xl.sheet_names
    finally:
        try:
            xl.close()
        except Exception:
            pass


def read_excel_sheet(xlsx_path: str, sheet_name: str) -> pd.DataFrame:
    return pd.read_excel(xlsx_path, sheet_name=sheet_name)


def extract_first_float_from_text(text: str) -> Optional[float]:
    if not isinstance(text, str):
        return None
    m = re.search(r"([-+]?\d+(?:\.\d+)?)", text)
    if not m:
        return None
    try:
        return float(m.group(1))
    except Exception:
        return None


def parse_flow_xy_from_columns(row: pd.Series, col_names: List[str]) -> Tuple[List[float], List[float]]:
    """
    Build (x, y) from a single row across selected columns.
    - x comes from the first float in the header (e.g., '0.5 L/min'); if none, uses 1,2,3…
    - y is the numeric in the row cell.
    Returns x,y sorted by x ascending.
    """
    xs: List[float] = []
    ys: List[float] = []
    next_idx = 1.0
    for c in col_names:
        y = row.get(c, None)
        x = extract_first_float_from_text(str(c))
        if x is None:
            x = next_idx
            next_idx += 1.0
        try:
            yn = float(y)
        except Exception:
            yn = None
        if yn is not None and np.isfinite(yn):
            xs.append(float(x))
            ys.append(float(yn))
    # Sort by x so plot is ordered
    if xs and ys and len(xs) == len(ys):
        order = np.argsort(xs)
        xs = [xs[i] for i in order]
        ys = [ys[i] for i in order]
    return xs, ys


def make_plot_ax(
    ax,
    xs: List[float],
    ys: List[float],
    include_trendline: bool,
    axis_label_fs: float,
    tick_fs: float,
):
    ax.clear()
    if not xs or not ys:
        ax.text(0.5, 0.5, "No data", ha="center", va="center", fontsize=max(6, tick_fs))
        ax.axis("off")
        return
    # Aesthetics tuned for small labels
    ax.plot(xs, ys, "-o", linewidth=1.0, markersize=2.5, color="#1a1a1a", label="Data")
    ax.set_xlabel("Air flow rate (L/min)", fontsize=axis_label_fs)
    ax.set_ylabel("Self-aspiration rate (µL/min)", fontsize=axis_label_fs)
    ax.tick_params(axis="both", labelsize=tick_fs, pad=2)
    ax.grid(True, linewidth=0.3, alpha=0.5)
    ax.margins(x=0.05, y=0.12)

    if include_trendline and len(xs) >= 2:
        try:
            coef = np.polyfit(xs, ys, 1)
            xfit = np.linspace(min(xs), max(xs), 100)
            yfit = np.polyval(coef, xfit)
            ax.plot(xfit, yfit, "-", color="#2b7bff", linewidth=1.0, label="Trend")
            ax.legend(loc="best", fontsize=max(6, tick_fs - 1))
        except Exception:
            pass


def _fmt_val(v: Optional[float], ndig: int = 2) -> str:
    try:
        if v is None or (hasattr(pd, "isna") and pd.isna(v)) or not np.isfinite(float(v)):
            return ""
        return f"{float(v):.{ndig}f}"
    except Exception:
        return ""


def _coerce_color_hex(s: str, fallback: str = DEFAULT_TITLE_COLOR) -> str:
    """Return a valid #RRGGBB hex or fallback."""
    ss = (s or "").strip()
    if re.fullmatch(r"#([0-9a-fA-F]{6})", ss):
        return ss
    return fallback


def render_pdf_label_matplotlib(
    out_pdf: Path,
    title_text: str,
    title_color: str,
    label_w_in: float,
    label_h_in: float,
    serial_value: str,
    backpressure_label: str,
    backpressure_value: Optional[float],
    vacuum_label: str,
    vacuum_value: Optional[float],
    flow_list_text: List[str],
    xs: List[float],
    ys: List[float],
    include_trendline: bool,
    leak_check: bool,
    visual_check: bool,
    plot_width_pct: int,
    text_scale_pct: int,
    margin_pct: int,
):
    # Scale factors
    tscale = max(50, min(200, int(text_scale_pct))) / 100.0  # clamp 50–200%
    # Base font sizes (pts), multiplied by tscale
    fs_title   = 11.0 * tscale
    fs_section = 8.5  * tscale
    fs_body    = 8.0  * tscale
    fs_italic  = 7.5  * tscale
    fs_flow    = 7.2  * tscale
    fs_axis    = 7.0  * tscale
    fs_tick    = 6.0  * tscale

    # Vertical spacing scale: close to tscale but a bit conservative
    vscale = min(1.6, max(0.7, tscale))

    # Margins (fraction of figure)
    margin_frac = max(0, min(25, int(margin_pct))) / 100.0

    fig = plt.figure(figsize=(label_w_in, label_h_in), dpi=PLOT_DPI)
    fig.subplots_adjust(0, 0, 1, 1)

    # Outer border
    fig.add_artist(Rectangle((0.003, 0.003), 0.994, 0.994, transform=fig.transFigure,
                             fill=False, linewidth=1, edgecolor="black"))

    lm = margin_frac
    rm = margin_frac
    tm = margin_frac
    bm = margin_frac

    total_w = 1 - lm - rm
    total_h = 1 - tm - bm

    plot_width_pct = max(30, min(80, int(plot_width_pct)))
    right_frac = plot_width_pct / 100.0
    left_w_frac = 1.0 - right_frac
    gap = 0.012
    right_w = max(0.01, total_w * right_frac - gap)

    # Left text column
    axL = fig.add_axes([lm, bm, total_w * left_w_frac, total_h])
    axL.axis("off")

    # Right plot column
    axR = fig.add_axes([lm + total_w * left_w_frac + gap, bm, right_w, total_h])

    # Left column content with scaled spacing
    y = 0.98
    axL.text(0.0, y, title_text, color=_coerce_color_hex(title_color), fontsize=fs_title,
             fontweight="bold", va="top", ha="left", transform=axL.transAxes)
    y -= 0.10 * vscale

    axL.text(0.0, y, "Calibration Data", color="black", fontsize=fs_section, va="top",
             ha="left", transform=axL.transAxes)
    y -= 0.10 * vscale

    axL.text(0.0, y, f"Serial Number: {serial_value}", fontsize=fs_body, va="top",
             ha="left", transform=axL.transAxes)
    y -= 0.08 * vscale

    bp_val = _fmt_val(backpressure_value, 2)
    axL.text(0.0, y, f"{backpressure_label}: {bp_val}", fontsize=fs_body, va="top",
             ha="left", transform=axL.transAxes)
    y -= 0.08 * vscale

    vac_val = _fmt_val(vacuum_value, 2)
    axL.text(0.0, y, f"{vacuum_label}: {vac_val}", fontsize=fs_body, va="top",
             ha="left", transform=axL.transAxes)
    y -= 0.10 * vscale

    axL.text(0.0, y, "Air flow rate (L/min)", fontsize=fs_italic, style="italic",
             va="top", ha="left", transform=axL.transAxes)
    y -= 0.08 * vscale

    axL.text(0.0, y, "Self-aspiration rate (µL/min)", fontsize=fs_italic, style="italic",
             va="top", ha="left", transform=axL.transAxes)
    y -= 0.10 * vscale

    # Flow list (truncate if needed to avoid the checkboxes area)
    for item in flow_list_text:
        if y < (0.20 if vscale >= 1.0 else 0.20 * vscale):
            break
        axL.text(0.0, y, item, fontsize=fs_flow, va="top", ha="left", transform=axL.transAxes)
        y -= 0.07 * vscale

    # Checkboxes (scale size modestly)
    def draw_checkbox(ax, x, ytop, label, checked):
        base_w, base_h = 0.05, 0.06
        cscale = min(1.4, max(0.8, tscale))
        box_w = base_w * cscale
        box_h = base_h * cscale
        ax.add_patch(Rectangle((x, ytop - box_h), box_w, box_h, fill=False, linewidth=0.8,
                               transform=ax.transAxes, clip_on=False, color="black"))
        if checked:
            ax.plot([x + 0.01, x + 0.02, x + box_w - 0.01],
                    [ytop - box_h + 0.02, ytop - 0.01, ytop - box_h + 0.02],
                    color="black", linewidth=1, transform=ax.transAxes, clip_on=False)
        ax.text(x + box_w + 0.02, ytop - box_h + 0.01, label, fontsize=fs_body,
                va="bottom", ha="left", transform=ax.transAxes)

    y_cb = max(y - 0.04 * vscale, 0.18)
    draw_checkbox(axL, 0.0, y_cb, "Leak check", leak_check)
    draw_checkbox(axL, 0.0, y_cb - (0.10 * vscale), "Visual inspection", visual_check)

    # Right plot
    make_plot_ax(axR, xs, ys, include_trendline, axis_label_fs=fs_axis, tick_fs=fs_tick)

    out_pdf.parent.mkdir(parents=True, exist_ok=True)
    with PdfPages(out_pdf) as pp:
        pp.savefig(fig, dpi=PLOT_DPI, bbox_inches="tight", pad_inches=0)
    plt.close(fig)


def pick_best_column_match(columns: List[str], keywords: List[str]) -> Optional[str]:
    lowered = [(c, str(c).lower()) for c in columns]
    for c, lc in lowered:
        if all(kw in lc for kw in keywords):
            return c
    return None


def _likely_flow_header(name: str) -> bool:
    """Heuristic: select headers that look like flow setpoints or contain 'flow'."""
    s = (name or "").lower()
    if "flow" in s:
        return True
    return extract_first_float_from_text(name) is not None


class ScrolledCheckFrame(ttk.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.canvas = tk.Canvas(self, borderwidth=0, highlightthickness=0)
        self.vsb = ttk.Scrollbar(self, orient="vertical", command=self.canvas.yview)
        self.canvas.configure(yscrollcommand=self.vsb.set)
        self.inner = ttk.Frame(self.canvas)

        self.inner.bind("<Configure>", lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all")))
        self.canvas.create_window((0, 0), window=self.inner, anchor="nw")

        self.canvas.grid(row=0, column=0, sticky="nsew")
        self.vsb.grid(row=0, column=1, sticky="ns")
        self.grid_rowconfigure(0, weight=1)
        self.grid_columnconfigure(0, weight=1)

        self.vars: List[tk.BooleanVar] = []
        self.cbs: List[tk.Checkbutton] = []
        for i in range(1, 21):
            var = tk.BooleanVar(value=False)
            cb = tk.Checkbutton(self.inner, text=f"Column {i}", variable=var, anchor="w", justify="left")
            cb.grid(row=i - 1, column=0, sticky="w", padx=4, pady=1)
            cb.grid_remove()
            self.vars.append(var)
            self.cbs.append(cb)

        btn_row = ttk.Frame(self.inner)
        btn_row.grid(row=21, column=0, sticky="w", pady=(6, 0))
        ttk.Button(btn_row, text="Select all", command=self.select_all).grid(row=0, column=0, padx=(0, 6))
        ttk.Button(btn_row, text="Select none", command=self.select_none).grid(row=0, column=1)

        self.columns: List[str] = []

    def load_columns(self, columns: List[str]):
        self.columns = list(columns)
        for i, cb in enumerate(self.cbs, start=1):
            if i - 1 < len(self.columns):
                name = str(self.columns[i - 1])
                default_on = _likely_flow_header(name)
                cb.configure(text=f"Column {i}: {name}")
                self.vars[i - 1].set(default_on)
                cb.grid()
            else:
                self.vars[i - 1].set(False)
                cb.grid_remove()

    def apply_selected_names(self, names: List[str]):
        name_set = set(names or [])
        for i in range(1, 21):
            if i - 1 < len(self.columns):
                self.vars[i - 1].set(self.columns[i - 1] in name_set)
            else:
                self.vars[i - 1].set(False)

    def selected_columns(self) -> List[str]:
        cols: List[str] = []
        for i, var in enumerate(self.vars, start=1):
            if var.get() and (i - 1) < len(self.columns):
                cols.append(self.columns[i - 1])
        # Keep selection ordered by numeric header value if present
        cols_sorted = sorted(
            cols,
            key=lambda c: (extract_first_float_from_text(str(c)) is None,
                           extract_first_float_from_text(str(c)) or float("inf"))
        )
        return cols_sorted

    def select_all(self):
        for i, var in enumerate(self.vars, start=1):
            if (i - 1) < len(self.columns):
                var.set(True)

    def select_none(self):
        for i, var in enumerate(self.vars, start=1):
            if (i - 1) < len(self.columns):
                var.set(False)


class SettingsManager:
    def __init__(self, path: Optional[Path] = None):
        self.path = path or default_settings_path()
        self.data = {}

    def load(self):
        try:
            if self.path.exists():
                with self.path.open("r", encoding="utf-8") as f:
                    self.data = json.load(f)
            else:
                self.data = {}
        except Exception:
            self.data = {}

    def save(self):
        try:
            self.path.parent.mkdir(parents=True, exist_ok=True)
            with self.path.open("w", encoding="utf-8") as f:
                json.dump(self.data, f, indent=2)
        except Exception as e:
            messagebox.showwarning("Settings", f"Could not save settings: {e}")

    def clear(self):
        try:
            if self.path.exists():
                self.path.unlink()
        except Exception:
            pass
        self.data = {}


def _find_serial_column(cols: List[str]) -> Optional[str]:
    for c in cols:
        s = str(c).strip().lower()
        if "serial" in s:
            return c
    return None


class App(ttk.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.master.title(APP_TITLE)
        self.pack(fill="both", expand=True)
        self.df: Optional[pd.DataFrame] = None
        self.xlsx_path: Optional[str] = None
        self.last_pdf: Optional[Path] = None

        self.settings = SettingsManager()
        self.settings.load()

        # Top: file picker
        file_frame = ttk.Frame(self)
        file_frame.pack(fill="x", padx=8, pady=6)

        ttk.Label(file_frame, text="Excel file:").pack(side="left")
        self.xlsx_var = tk.StringVar()
        ttk.Entry(file_frame, textvariable=self.xlsx_var, width=60).pack(side="left", padx=6)
        ttk.Button(file_frame, text="Browse...", command=self.on_browse).pack(side="left")

        # Sheet + Serial row
        sheet_serial = ttk.Frame(self)
        sheet_serial.pack(fill="x", padx=8, pady=4)

        ttk.Label(sheet_serial, text="Sheet:").pack(side="left")
        self.sheet_var = tk.StringVar()
        self.sheet_menu = ttk.Combobox(sheet_serial, textvariable=self.sheet_var, width=28, state="readonly")
        self.sheet_menu.pack(side="left", padx=(4, 16))
        self.sheet_menu.bind("<<ComboboxSelected>>", lambda e: self.load_sheet())

        ttk.Label(sheet_serial, text="Serial:").pack(side="left")
        self.serial_var = tk.StringVar()
        self.serial_menu = ttk.Combobox(sheet_serial, textvariable=self.serial_var, width=24, state="readonly")
        self.serial_menu.pack(side="left", padx=(4, 0))

        # Title/color row
        title_frame = ttk.Frame(self)
        title_frame.pack(fill="x", padx=8, pady=4)

        ttk.Label(title_frame, text="Title:").pack(side="left")
        self.title_var = tk.StringVar(value=self.settings.data.get("title", DEFAULT_TITLE))
        ttk.Entry(title_frame, textvariable=self.title_var, width=28).pack(side="left", padx=(4, 16))

        ttk.Label(title_frame, text="Color (hex):").pack(side="left")
        self.title_color_var = tk.StringVar(value=self.settings.data.get("title_color", DEFAULT_TITLE_COLOR))
        ttk.Entry(title_frame, textvariable=self.title_color_var, width=12).pack(side="left")

        # Size/plot row
        dims_frame = ttk.Frame(self)
        dims_frame.pack(fill="x", padx=8, pady=4)

        ttk.Label(dims_frame, text="Label size (in):").pack(side="left")
        ttk.Label(dims_frame, text="W").pack(side="left")
        self.win_var = tk.StringVar(value=str(self.settings.data.get("label_w_in", DEFAULT_LABEL_W_IN)))
        ttk.Entry(dims_frame, textvariable=self.win_var, width=6).pack(side="left", padx=(2, 8))

        ttk.Label(dims_frame, text="H").pack(side="left")
        self.hin_var = tk.StringVar(value=str(self.settings.data.get("label_h_in", DEFAULT_LABEL_H_IN)))
        ttk.Entry(dims_frame, textvariable=self.hin_var, width=6).pack(side="left", padx=(2, 16))

        # Plot width % (Spinbox 30–80)
        ttk.Label(dims_frame, text="Plot width %").pack(side="left")

        self.plotw_var = tk.IntVar(value=int(self.settings.data.get("plot_width_pct", 52)))
        self.plotw_sb = tk.Spinbox(
            dims_frame,
            from_=30, to=80, increment=1,
            textvariable=self.plotw_var, width=5, justify="right"
        )
        self.plotw_sb.pack(side="left", padx=(4, 12))

        # Clamp to range on Enter/blur
        self._bind_spinbox_int(self.plotw_sb, self.plotw_var, 30, 80, 52)

        self.trend_var = tk.BooleanVar(value=bool(self.settings.data.get("trendline", True)))
        ttk.Checkbutton(dims_frame, text="Include trendline", variable=self.trend_var).pack(side="left")

        # Typography & margins row
        typo_frame = ttk.Frame(self)
        typo_frame.pack(fill="x", padx=8, pady=4)
        # Text scale % (Spinbox 60–160)
        ttk.Label(typo_frame, text="Text scale %").pack(side="left")
        self.text_scale_var = tk.IntVar(value=int(self.settings.data.get("text_scale_pct", DEFAULT_TEXT_SCALE_PCT)))
        self.text_scale_sb = tk.Spinbox(
            typo_frame,
            from_=60, to=160, increment=1,
            textvariable=self.text_scale_var, width=5, justify="right"
)
        self.text_scale_sb.pack(side="left", padx=(4, 16))
        self._bind_spinbox_int(self.text_scale_sb, self.text_scale_var, 60, 160, DEFAULT_TEXT_SCALE_PCT)

        # Margins % (Spinbox 3–15)
        ttk.Label(typo_frame, text="Margins %").pack(side="left")
        self.margin_var = tk.IntVar(value=int(self.settings.data.get("margin_pct", DEFAULT_MARGIN_PCT)))
        self.margin_sb = tk.Spinbox(
            typo_frame,
            from_=3, to=15, increment=1,
            textvariable=self.margin_var, width=5, justify="right"
        )
        self.margin_sb.pack(side="left", padx=(4, 0))
        self._bind_spinbox_int(self.margin_sb, self.margin_var, 3, 15, DEFAULT_MARGIN_PCT)



        # Backpressure/Vacuum selectors
        bp_vac = ttk.Frame(self)
        bp_vac.pack(fill="x", padx=8, pady=4)

        ttk.Label(bp_vac, text="Backpressure column:").pack(side="left")
        self.bp_col_var = tk.StringVar()
        self.bp_col_menu = ttk.Combobox(bp_vac, textvariable=self.bp_col_var, width=32, state="readonly")
        self.bp_col_menu.pack(side="left", padx=(4, 16))

        ttk.Label(bp_vac, text="Vacuum column:").pack(side="left")
        self.vc_col_var = tk.StringVar()
        self.vc_col_menu = ttk.Combobox(bp_vac, textvariable=self.vc_col_var, width=32, state="readonly")
        self.vc_col_menu.pack(side="left", padx=(4, 0))

        # Columns chooser
        cols_frame = ttk.LabelFrame(self, text="Choose columns (1–20) to plot (in order)")
        cols_frame.pack(fill="both", padx=8, pady=8, expand=True)
        self.scrolled_checks = ScrolledCheckFrame(cols_frame)
        self.scrolled_checks.pack(fill="both", expand=True, padx=6, pady=6)

        # Checkboxes row
        checks = ttk.Frame(self)
        checks.pack(fill="x", padx=8, pady=4)
        self.leak_var = tk.BooleanVar(value=bool(self.settings.data.get("leak_check", False)))
        ttk.Checkbutton(checks, text="Leak check", variable=self.leak_var).pack(side="left", padx=(0, 12))
        self.visual_var = tk.BooleanVar(value=bool(self.settings.data.get("visual_check", False)))
        ttk.Checkbutton(checks, text="Visual inspection", variable=self.visual_var).pack(side="left")

        # Output actions
        out_actions = ttk.Frame(self)
        out_actions.pack(fill="x", padx=8, pady=6)
        ttk.Label(out_actions, text="Output folder:").pack(side="left")
        self.outdir_var = tk.StringVar(value=self.settings.data.get("out_dir", ""))
        ttk.Entry(out_actions, textvariable=self.outdir_var, width=54).pack(side="left", padx=6)
        ttk.Button(out_actions, text="Browse...", command=self.on_browse_outdir).pack(side="left", padx=(0, 12))
        ttk.Button(out_actions, text="Generate PDF", command=self.on_generate).pack(side="left")
        self.open_btn = ttk.Button(out_actions, text="Open PDF", command=self.on_open_pdf, state="disabled")
        self.open_btn.pack(side="left", padx=(8, 0))
        ttk.Button(out_actions, text="Save settings", command=self.on_save_settings).pack(side="left", padx=(12, 0))
        ttk.Button(out_actions, text="Reset settings", command=self.on_reset_settings).pack(side="left", padx=(6, 0))

        # Status bar
        self.status_var = tk.StringVar(value="")
        status = ttk.Label(self, textvariable=self.status_var, relief="sunken", anchor="w")
        status.pack(fill="x", padx=0, pady=(4, 0), ipady=2)

        self.apply_saved_settings()
        self.master.protocol("WM_DELETE_WINDOW", self.on_close)

    def set_status(self, msg: str):
        self.status_var.set(msg)
        self.update_idletasks()

    def apply_saved_settings(self):
        s = self.settings.data or {}

        # Load Excel (if present)
        xlsx = s.get("xlsx_path", "")
        if xlsx and Path(xlsx).exists():
            self.xlsx_path = xlsx
            self.xlsx_var.set(xlsx)
            try:
                sheets = read_excel_sheet_names(xlsx)
                self.sheet_menu["values"] = sheets
                sheet_name = s.get("sheet_name")
                if sheet_name in sheets:
                    self.sheet_var.set(sheet_name)
                elif sheets:
                    self.sheet_var.set(sheets[0])
                if self.sheet_var.get():
                    self.load_sheet()
            except Exception as e:
                self.set_status(f"Error reading Excel: {e}")

        # Re-apply saved column and serial selections if df loaded
        if self.df is not None:
            cols = list(self.df.columns)
            # Serials (normalized display)
            if "_SerialStr" in self.df.columns:
                serial_vals = [s for s in sorted(self.df["_SerialStr"].dropna().unique().tolist()) if s and s.lower() != "nan"]
            else:
                serial_vals = []
            saved_serial = s.get("serial")
            if saved_serial and (saved_serial in serial_vals):
                self.serial_var.set(saved_serial)

            saved_bp = s.get("bp_col"); saved_vc = s.get("vc_col")
            if saved_bp in cols:
                self.bp_col_var.set(saved_bp)
            if saved_vc in cols:
                self.vc_col_var.set(saved_vc)

            saved_selected = s.get("selected_columns_by_name", [])
            self.scrolled_checks.apply_selected_names(saved_selected)

        if not self.outdir_var.get() and self.xlsx_path:
            self.outdir_var.set(str(Path(self.xlsx_path).parent))

    def current_settings(self) -> dict:
        s = {
            "title": self.title_var.get().strip() or DEFAULT_TITLE,
            "title_color": self.title_color_var.get().strip() or DEFAULT_TITLE_COLOR,
            "label_w_in": safe_float(self.win_var.get(), DEFAULT_LABEL_W_IN),
            "label_h_in": safe_float(self.hin_var.get(), DEFAULT_LABEL_H_IN),
            "plot_width_pct": int(self.plotw_var.get()),
            "trendline": bool(self.trend_var.get()),
            "leak_check": bool(self.leak_var.get()),
            "visual_check": bool(self.visual_var.get()),
            "out_dir": self.outdir_var.get().strip(),
            "xlsx_path": self.xlsx_path or "",
            "sheet_name": self.sheet_var.get().strip(),
            "serial": self.serial_var.get().strip(),
            "bp_col": self.bp_col_var.get().strip() if self.bp_col_var.get() else "",
            "vc_col": self.vc_col_var.get().strip() if self.vc_col_var.get() else "",
            "selected_columns_by_name": self.scrolled_checks.selected_columns(),
            "text_scale_pct": int(self.text_scale_var.get()),
            "margin_pct": int(self.margin_var.get()),
        }
        return s

    def on_save_settings(self):
        self.settings.data = self.current_settings()
        self.settings.save()
        self.set_status(f"Settings saved to: {self.settings.path}")

    def on_reset_settings(self):
        if messagebox.askyesno("Reset settings", "Clear saved settings and revert to defaults?"):
            self.settings.clear()
            self.set_status("Settings cleared. Defaults will be used next launch.")

    def on_close(self):
        self.on_save_settings()
        self.master.destroy()

    def on_browse(self):
        path = filedialog.askopenfilename(
            title="Select Excel file",
            filetypes=[("Excel files", "*.xlsx *.xlsm *.xls"), ("All files", "*.*")]
        )
        if not path:
            return
        self.xlsx_path = path
        self.xlsx_var.set(path)
        try:
            sheets = read_excel_sheet_names(path)
            self.sheet_menu["values"] = sheets
            if sheets:
                self.sheet_var.set(sheets[0])
                self.load_sheet()
            if not self.outdir_var.get():
                self.outdir_var.set(str(Path(path).parent))
            self.set_status(f"Loaded: {path}")
        except Exception as e:
            messagebox.showerror("Error", f"Error reading Excel: {e}")
            self.set_status(f"Error reading Excel: {e}")

    def load_sheet(self):
        if not self.xlsx_path or not self.sheet_var.get():
            return
        try:
            self.df = read_excel_sheet(self.xlsx_path, self.sheet_var.get())
            cols = list(self.df.columns)

            # Find serial column; normalize to string for reliable matching/display
            serial_col = "Serial Number" if "Serial Number" in cols else _find_serial_column(cols)
            if serial_col:
                self.df["_SerialStr"] = self.df[serial_col].astype(str).str.strip()
                serials = [
                    s for s in sorted(self.df["_SerialStr"].dropna().unique().tolist())
                    if s and s.lower() != "nan"
                ]
            else:
                serials = []

            # Fill column selection (heuristic preselection)
            self.scrolled_checks.load_columns(cols)

            # Backpressure/vacuum guesses
            bp_guess = pick_best_column_match(cols, ["pressure", "@0.7"]) or pick_best_column_match(cols, ["pressure"])
            vc_guess = pick_best_column_match(cols, ["vacuum", "@0.7"]) or pick_best_column_match(cols, ["vacuum"])
            self.bp_col_menu["values"] = cols
            self.vc_col_menu["values"] = cols
            if not self.bp_col_var.get() and bp_guess:
                self.bp_col_var.set(bp_guess)
            if not self.vc_col_var.get() and vc_guess:
                self.vc_col_var.set(vc_guess)

            # Serials menu (use normalized strings)
            self.serial_menu["values"] = serials
            if serials and not self.serial_var.get():
                self.serial_var.set(serials[0])

            if not self.outdir_var.get():
                self.outdir_var.set(str(Path(self.xlsx_path).parent))
            self.set_status(f"Loaded sheet: {self.sheet_var.get()} ({len(self.df)} rows, {len(self.df.columns)} cols)")
        except Exception as e:
            self.df = None
            messagebox.showerror("Error", f"Error loading sheet: {e}")
            self.set_status(f"Error loading sheet: {e}")

    def on_browse_outdir(self):
        path = filedialog.askdirectory(title="Select output folder")
        if path:
            self.outdir_var.set(path)

    def on_generate(self):
        if self.df is None:
            messagebox.showerror("Missing data", "Load an Excel file and sheet first.")
            return

        title_text = self.title_var.get().strip() or DEFAULT_TITLE
        title_color = _coerce_color_hex(self.title_color_var.get().strip(), DEFAULT_TITLE_COLOR)

        try:
            label_w_in = float(self.win_var.get())
            label_h_in = float(self.hin_var.get())
            if label_w_in <= 0 or label_h_in <= 0:
                raise ValueError
        except Exception:
            messagebox.showerror("Invalid size", "Label width/height must be positive numbers (inches).")
            return

        plot_width_pct = int(self.plotw_var.get())
        text_scale_pct = int(self.text_scale_var.get())
        margin_pct = int(self.margin_var.get())

        # Ensure normalized serial string column exists
        if "_SerialStr" not in self.df.columns:
            serial_col = "Serial Number" if "Serial Number" in self.df.columns else _find_serial_column(list(self.df.columns))
            if serial_col:
                self.df["_SerialStr"] = self.df[serial_col].astype(str).str.strip()
            else:
                self.df["_SerialStr"] = self.df.index.astype(str)

        # Pick row for serial using normalized string; fallback to last row
        serial = self.serial_var.get().strip()
        if serial and ("_SerialStr" in self.df.columns):
            dff = self.df[self.df["_SerialStr"] == serial]
            if len(dff) == 0:
                messagebox.showerror("Not found", "Selected Serial Number not found.")
                return
            # If there is a likely datetime column, use latest; else last
            date_col = None
            for cand in ["Testing Date", "Test Date", "Date", "Timestamp", "Testing Data"]:
                if cand in dff.columns:
                    date_col = cand
                    break
            if date_col is not None:
                try:
                    dff = dff.sort_values(date_col)
                except Exception:
                    pass
            sel_row = dff.iloc[-1]
        else:
            sel_row = self.df.iloc[-1]
        serial_value = str(sel_row.get("_SerialStr", "")) or str(sel_row.get("Serial Number", ""))

        # Backpressure / vacuum
        bp_col = self.bp_col_var.get() or None
        vc_col = self.vc_col_var.get() or None
        bp_val = sel_row.get(bp_col) if bp_col else None
        vc_val = sel_row.get(vc_col) if vc_col else None
        try:
            bp_val = float(bp_val)
        except Exception:
            pass
        try:
            vc_val = float(vc_val)
        except Exception:
            pass

        # Columns to plot
        selected_cols = self.scrolled_checks.selected_columns()
        if not selected_cols:
            messagebox.showerror("No columns", "Select at least one column to plot.")
            return
        xs, ys = parse_flow_xy_from_columns(sel_row, selected_cols)
        include_trendline = bool(self.trend_var.get())

        # Flow list text
        flow_items: List[str] = []
        for c in selected_cols:
            setpoint = extract_first_float_from_text(str(c))
            val = sel_row.get(c)
            val_fmt = _fmt_val(val, 2)
            if setpoint is not None:
                flow_items.append(f"{setpoint:g} L/min \u2192 {val_fmt} \u00B5L/min")
            else:
                flow_items.append(f"{c}: {val_fmt} \u00B5L/min")

        out_dir = self.outdir_var.get().strip() or (str(Path(self.xlsx_path).parent) if self.xlsx_path else str(Path.cwd()))
        Path(out_dir).mkdir(parents=True, exist_ok=True)
        out_pdf = Path(out_dir) / f"label_{serial_value or 'row'}.pdf"

        try:
            render_pdf_label_matplotlib(
                out_pdf=out_pdf,
                title_text=title_text,
                title_color=title_color,
                label_w_in=label_w_in,
                label_h_in=label_h_in,
                serial_value=serial_value,
                backpressure_label=(bp_col or "Backpressure"),
                backpressure_value=bp_val,
                vacuum_label=(vc_col or "Vacuum"),
                vacuum_value=vc_val,
                flow_list_text=flow_items,
                xs=xs,
                ys=ys,
                include_trendline=include_trendline,
                leak_check=bool(self.leak_var.get()),
                visual_check=bool(self.visual_var.get()),
                plot_width_pct=plot_width_pct,
                text_scale_pct=text_scale_pct,
                margin_pct=margin_pct,
            )
            self.last_pdf = out_pdf
            self.open_btn.configure(state="normal")
            self.set_status(f"PDF generated: {out_pdf}")
            self.on_save_settings()
        except Exception as e:
            messagebox.showerror("Error", f"Failed to generate PDF: {e}")
            self.set_status(f"Failed to generate PDF: {e}")

    def on_open_pdf(self):
        if not self.last_pdf or not self.last_pdf.exists():
            messagebox.showwarning("No PDF", "No PDF has been generated yet.")
            return
        try:
            if sys.platform.startswith("win"):
                os.startfile(str(self.last_pdf))  # type: ignore[attr-defined]
            elif sys.platform == "darwin":
                os.system(f"open '{self.last_pdf}'")
            else:
                os.system(f"xdg-open '{self.last_pdf}'")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to open PDF: {e}")

    def _bind_spinbox_int(self, spin: tk.Spinbox, var: tk.IntVar, min_val: int, max_val: int, default: int):
        """Clamp spinbox value on Enter/FocusOut to [min_val, max_val] or default if invalid."""
        def clamp_event(_=None):
            try:
                v = int(var.get())
            except Exception:
                v = default
            if v < min_val:
                v = min_val
            if v > max_val:
                v = max_val
            var.set(v)
        spin.bind("<Return>", clamp_event)
        spin.bind("<FocusOut>", clamp_event)
        

def safe_float(val, default):
    """
    Return a positive float from val, or default if parsing fails or <= 0.
    """
    try:
        f = float(val)
        return f if f > 0 else default
    except Exception:
        return default


def main():
    root = tk.Tk()
    try:
        if sys.platform.startswith("win"):
            root.tk.call('tk', 'scaling', 1.25)
    except Exception:
        pass
    App(root)
    root.minsize(880, 640)
    root.mainloop()


if __name__ == "__main__":
    main()
