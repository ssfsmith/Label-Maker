"""
Label Maker (Profiles) - single-file app

- Profile tab: Template & Layout + Output (persisted in profile)
- Bindings tab: Graph bindings and Value bindings (scrollable, persisted)
- Actions tab: Preview & Generate
- Data Source tab (last): Excel path, sheet, serial selection + Save button

Bindings persistence:
- Flow columns (X) listbox: saved on selection
- Graph Value slots: label entries saved on focus-out; column comboboxes saved on selection
- Non-graph Value bindings: same behavior
- Explicit "Save Bindings" button writes to disk and flashes confirmation

Output persistence:
- Output target, filename pattern, copies, open-after, output folder
"""

import os, sys
HERE = os.path.dirname(os.path.abspath(__file__))
if HERE not in sys.path:
    sys.path.insert(0, HERE)

from pathlib import Path
from typing import List, Dict, Optional

import tkinter as tk
from tkinter import ttk, filedialog, messagebox

import pandas as pd

from render import (
    PROFILE_DIR,
    TEMPLATE_GRAPH, TEMPLATE_VALUE_A, TEMPLATE_VALUE_B, TEMPLATE_VALUE_C,
    TARGET_LETTER_TWO_UP, TARGET_LX900_3x4,
    DEFAULT_TITLE_COLOR, DEFAULT_TEXT_SCALE_PCT, DEFAULT_MARGIN_PCT, DEFAULT_PLOT_WIDTH_PCT,
    read_excel_sheet_names, read_excel_sheet, list_profiles, default_profile, save_profile, load_profile,
    render_profile_to_pdf,
)

APP_TITLE = "Label Maker (Profiles)"

class ScrollableFrame(ttk.Frame):
    """Scrollable area that auto-disables scrolling when not needed."""
    def __init__(self, container, *args, **kwargs):
        super().__init__(container, *args, **kwargs)

        # Match TTK frame background so it doesn't look like a gray box
        try:
            style = ttk.Style()
            bg = style.lookup("TFrame", "background") or self.cget("background")
        except Exception:
            bg = self.cget("background")

        self.canvas = tk.Canvas(self, borderwidth=0, highlightthickness=0, bg=bg)
        self.vscroll = ttk.Scrollbar(self, orient="vertical", command=self.canvas.yview)
        self.scrollable_frame = ttk.Frame(self.canvas)

        # Place inner frame and keep a reference to the window id
        self._window_id = self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")

        # When inner content changes size -> update scrollregion and scrollbar visibility
        self.scrollable_frame.bind("<Configure>", lambda e: self._on_frame_configure())
        # When canvas changes size -> stretch inner frame to canvas width and reevaluate
        self.canvas.bind("<Configure>", lambda e: self._on_canvas_configure())

        self.canvas.pack(side="left", fill="both", expand=True)
        self.vscroll.pack(side="right", fill="y")

        # Mouse wheel binding is toggled depending on need
        self._wheel_bound = False

    def _on_frame_configure(self):
        try:
            self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        except Exception:
            pass
        self._update_scrollbar_visibility()

    def _on_canvas_configure(self):
        # Stretch inner frame to the canvas width to avoid narrow “box”
        try:
            self.canvas.itemconfigure(self._window_id, width=self.canvas.winfo_width())
        except Exception:
            pass
        self._update_scrollbar_visibility()

    def _update_scrollbar_visibility(self):
        # Show scrollbar and enable wheel only if content is taller than viewport
        try:
            need = self.scrollable_frame.winfo_reqheight() > self.canvas.winfo_height()
        except Exception:
            need = False

        if need:
            # ensure connections and show bar
            self.canvas.configure(yscrollcommand=self.vscroll.set)
            if not self.vscroll.winfo_ismapped():
                self.vscroll.pack(side="right", fill="y")
            self._bind_wheel()
        else:
            # lock at top and hide bar
            try:
                self.canvas.yview_moveto(0)
            except Exception:
                pass
            if self.vscroll.winfo_ismapped():
                self.vscroll.pack_forget()
            self.canvas.configure(yscrollcommand=None)
            self._unbind_wheel()

    def _bind_wheel(self):
        if self._wheel_bound:
            return
        for w in (self.canvas, self.scrollable_frame):
            # Windows/macOS
            w.bind("<MouseWheel>", self._on_mousewheel)
            # Linux
            w.bind("<Button-4>", self._on_mousewheel)
            w.bind("<Button-5>", self._on_mousewheel)
        self._wheel_bound = True

    def _unbind_wheel(self):
        if not self._wheel_bound:
            return
        for w in (self.canvas, self.scrollable_frame):
            w.unbind("<MouseWheel>")
            w.unbind("<Button-4>")
            w.unbind("<Button-5>")
        self._wheel_bound = False

    def _on_mousewheel(self, event):
        try:
            # Linux (button-based)
            if getattr(event, "num", None) == 4:
                self.canvas.yview_scroll(-1, "units"); return
            if getattr(event, "num", None) == 5:
                self.canvas.yview_scroll(1, "units"); return
            # Windows/macOS (delta-based)
            if event.delta < 0:
                self.canvas.yview_scroll(1, "units")
            elif event.delta > 0:
                self.canvas.yview_scroll(-1, "units")
        except Exception:
            pass

class LayoutEditor(ttk.Frame):
    """
    Visual layout editor for Template & Layout.
    - Canvas shows a scaled label with inner margins.
    - Drag the title/static text, labels/values columns, row start, graph splitter, and logo.
    - Sliders for line height and graph margin; toggles for snap/grid/guides.
    All positions stored as percentages of the inner label area (or the 'left' area for text/columns in graph mode),
    matching the fields your renderer reads.
    """
    def __init__(self, parent, app, width=720, height=420):
        super().__init__(parent)
        self.app = app
        self.W = width
        self.H = height
        self.bg = "#f7f7fa"
        self.snap = tk.BooleanVar(value=True)
        self.show_guides = tk.BooleanVar(value=True)

        # Canvas
        self.canvas = tk.Canvas(self, width=self.W, height=self.H, bg=self.bg, highlightthickness=1, highlightbackground="#ccc")
        self.canvas.grid(row=0, column=0, columnspan=4, sticky="nsew", padx=(0, 8), pady=(0, 8))
        self.columnconfigure(0, weight=1)
        self.rowconfigure(0, weight=1)

        # Controls row
        ttk.Checkbutton(self, text="Snap to grid", variable=self.snap, command=self.refresh).grid(row=1, column=0, sticky="w")
        ttk.Checkbutton(self, text="Show guides", variable=self.show_guides, command=self.refresh).grid(row=1, column=1, sticky="w")
        ttk.Button(self, text="Reset layout", command=self.reset_layout).grid(row=1, column=2, sticky="w")

        # Sliders
        self.line_h_var = tk.DoubleVar(value=float(self._tpl("line_height_pct", 0.075)))
        self.graph_margin_var = tk.IntVar(value=int(self._tpl("graph_margin_pct", self._profile("margin_pct", 7))))
        ttk.Label(self, text="Line height").grid(row=2, column=0, sticky="w")
        ttk.Scale(self, from_=0.04, to=0.12, orient="horizontal", variable=self.line_h_var, command=lambda *_: self._on_line_h_change()).grid(row=2, column=1, sticky="we", padx=(6, 12))
        ttk.Label(self, text="Graph margin %").grid(row=2, column=2, sticky="e")
        ttk.Spinbox(self, from_=0, to=25, width=5, textvariable=self.graph_margin_var, command=self._on_graph_margin_change, justify="right").grid(row=2, column=3, sticky="w")

        # Internal: canvas items
        self.items = {}
        self.drag = {"item": None, "kind": None, "dx": 0, "dy": 0, "anchor": None}

        # Bind mouse
        self.canvas.bind("<Button-1>", self._on_down)
        self.canvas.bind("<B1-Motion>", self._on_drag)
        self.canvas.bind("<ButtonRelease-1>", self._on_up)

        self.refresh()

    # --------- profile helpers ---------
    def _profile(self, key, default=None):
        return self.app.profile.get(key, default)

    def _tpl(self, key, default=None):
        return self.app.profile.get("template", {}).get(key, default)

    def _bindings(self):
        return self.app.profile.setdefault("bindings", {})

    def _setp(self, key, val):
        self.app.profile[key] = val
        try: self.app._schedule_autosave()
        except Exception: pass

    def _sett(self, key, val):
        self.app.profile.setdefault("template", {})[key] = val
        try: self.app._schedule_autosave()
        except Exception: pass

    # --------- geometry helpers ---------
    def _snapv(self, v, step):
        return round(v / step) * step if self.snap.get() else v

    def _inner_rect(self):
        # Returns inner rectangle (left, top, right, bottom) in canvas coords, after margins
        margin_pct = int(self._profile("margin_pct", 7))
        m = (margin_pct / 100.0)
        l = self.W * m
        t = self.H * m
        r = self.W * (1 - m)
        b = self.H * (1 - m)
        return l, t, r, b

    def _split_left_rect(self):
        # Left area (values/labels) rect; if graph enabled, split by plot_width_pct
        l, t, r, b = self._inner_rect()
        include_graph = bool(self._tpl("include_graph", False))
        if not include_graph:
            return l, t, r, b, None  # left, top, right, bottom, splitter_x
        plotw = int(self._profile("plot_width_pct", 52))
        plotw = max(30, min(80, plotw))
        right_frac = plotw / 100.0
        total_w = r - l
        left_w = total_w * (1.0 - right_frac)
        split_x = l + left_w
        return l, t, split_x, b, split_x

    def _left_localize(self, x_canvas, y_canvas):
        # Convert canvas coords to normalized 0..1 within left area
        l, t, r, b, _ = self._split_left_rect()
        u = 0.0 if r <= l else (x_canvas - l) / (r - l)
        v = 0.0 if b <= t else (y_canvas - t) / (b - t)
        return max(0.0, min(1.0, u)), max(0.0, min(1.0, v))

    def _left_to_canvas(self, u, v):
        l, t, r, b, _ = self._split_left_rect()
        x = l + u * (r - l)
        y = t + v * (b - t)
        return x, y

    # --------- drawing ---------
    def refresh(self):
        self.canvas.delete("all")
        # Background inner/outer
        l, t, r, b = 8, 8, self.W - 8, self.H - 8
        self.canvas.create_rectangle(l, t, r, b, outline="#bbb", width=1, fill="#fff")

        il, it, ir, ib = self._inner_rect()
        self.canvas.create_rectangle(il, it, ir, ib, outline="#222", width=1)

        # Left vs graph split
        ll, lt, lr, lb, split_x = self._split_left_rect()
        self.canvas.create_rectangle(ll, lt, lr, lb, outline="#999", width=1)
        include_graph = bool(self._tpl("include_graph", False))
        if include_graph:
            # draw graph area
            self.canvas.create_rectangle(lr, lt, ir, ib, outline="#999", width=1)
            # splitter bar
            self.items["splitter"] = self.canvas.create_rectangle(lr - 3, lt, lr + 3, lb, fill="#0E6CD6", outline="")
        else:
            self.items["splitter"] = None

        # Guides (grid)
        if self.show_guides.get():
            step = 0.05
            # vertical grid in left area
            x = 0.0
            while x <= 1.0001:
                cx, _ = self._left_to_canvas(x, 0.0)
                self.canvas.create_line(cx, lt, cx, lb, fill="#eee")
                x += step
            # horizontal grid
            y = 0.0
            while y <= 1.0001:
                _, cy = self._left_to_canvas(0.0, y)
                self.canvas.create_line(ll, cy, lr, cy, fill="#eee")
                y += step

        # Title handle
        ux = float(self._profile("title_x_pct", 0.0))
        uy = float(self._profile("title_y_pct", 0.96))
        ux = max(0.0, min(1.0, ux)); uy = max(0.0, min(1.0, uy))
        tx, ty = self._left_to_canvas(ux, uy)
        self.items["title"] = self.canvas.create_oval(tx-6, ty-6, tx+6, ty+6, fill="#333", outline="white")
        self.canvas.create_text(tx+10, ty, text="Title", anchor="w", fill="#333")

        # Static text handle (if enabled)
        if bool(self._profile("static_text_enabled", False)):
            sux = float(self._profile("static_text_x_pct", 0.0))
            suy = float(self._profile("static_text_y_pct", 0.86))
            sx, sy = self._left_to_canvas(sux, suy)
            self.items["static"] = self.canvas.create_rectangle(sx-6, sy-6, sx+6, sy+6, fill="#444", outline="white")
            self.canvas.create_text(sx+10, sy, text="Static text", anchor="w", fill="#444")
        else:
            self.items["static"] = None

        # Labels/Values columns and top row start
        lx = float(self._profile("labels_x_pct", 0.0))
        vx = self._profile("values_x_pct", None)
        gap = float(self._profile("label_value_gap_pct", 0.10))
        if vx is None:
            vx = lx + gap
        ly = float(self._profile("rows_top_y_pct", 0.78))
        lx = max(0.0, min(1.0, lx)); vx = max(0.0, min(1.0, vx)); ly = max(0.0, min(1.0, ly))

        lcx, lcy = self._left_to_canvas(lx, ly)
        vcx, vcy = self._left_to_canvas(vx, ly)
        # vertical handles
        self.items["labels_col"] = self.canvas.create_line(lcx, lt, lcx, lb, fill="#0a7", width=2)
        self.items["values_col"] = self.canvas.create_line(vcx, lt, vcx, lb, fill="#a70", width=2)
        # row start handle
        self.items["rows_top"] = self.canvas.create_oval(lcx-5, lcy-5, lcx+5, lcy+5, fill="#0a7", outline="white")
        self.canvas.create_text(lcx+10, lcy, text="Row start", anchor="w", fill="#0a7")

        # Logo box (value labels only)
        bindings = self._bindings()
        logo_path = (bindings.get("logo_path", "") or "").strip()
        if (not include_graph) and logo_path:
            x_pct = float(self._profile("logo_x_pct", 0.02))
            y_pct = float(self._profile("logo_y_pct", 0.70))
            w_pct = float(self._profile("logo_w_pct", 0.28))
            h_pct = float(self._profile("logo_h_pct", 0.0))  # 0 = auto height by width
            # absolute in inner area (not just left side)
            il, it, ir, ib = self._inner_rect()
            L = il + x_pct * (ir - il)
            T = it + y_pct * (ib - it)
            W = w_pct * (ir - il)
            if h_pct and h_pct > 0:
                H = h_pct * (ib - it)
            else:
                H = W * 0.35
            self.items["logo_box"] = self.canvas.create_rectangle(L, T, L+W, T+H, outline="#08c", width=2)
            # resize handle
            self.items["logo_resize"] = self.canvas.create_rectangle(L+W-6, T+H-6, L+W+6, T+H+6, fill="#08c", outline="")
        else:
            self.items["logo_box"] = None
            self.items["logo_resize"] = None

        # Labels under controls
        self.canvas.create_text(ll+8, lb-14, text="Drag dots/lines to move; drag splitter to resize graph area; drag logo to move/resize", anchor="w", fill="#666", font=("Segoe UI", 9))

    # --------- event handlers ---------
    def _hit_kind(self, item):
        for k, it in self.items.items():
            if it == item:
                return k
        return None

    def _on_down(self, e):
        item = self.canvas.find_closest(e.x, e.y)[0]
        kind = self._hit_kind(item)
        self.drag = {"item": item, "kind": kind, "dx": e.x, "dy": e.y, "anchor": None}

    def _on_drag(self, e):
        if not self.drag["item"]:
            return
        kind = self.drag["kind"]
        dx = e.x - self.drag["dx"]
        dy = e.y - self.drag["dy"]
        self.drag["dx"], self.drag["dy"] = e.x, e.y

        if kind in ("title", "static"):
            # move within left area
            u, v = self._left_localize(e.x, e.y)
            step = 0.02
            u = self._snapv(u, step); v = self._snapv(v, step)
            if kind == "title":
                self._setp("title_x_pct", u); self._setp("title_y_pct", v)
            else:
                self._setp("static_text_x_pct", u); self._setp("static_text_y_pct", v)
            self.refresh(); return

        if kind in ("labels_col", "values_col"):
            # horizontal drag; lock y
            ll, lt, lr, lb, _ = self._split_left_rect()
            x = max(ll, min(lr, e.x))
            u, _ = self._left_localize(x, lt)
            u = self._snapv(u, 0.02)
            if kind == "labels_col":
                self._setp("labels_x_pct", u)
            else:
                self._setp("values_x_pct", u)
            self.refresh(); return

        if kind == "rows_top":
            # vertical drag for row start
            _, v = self._left_localize(self.drag["dx"], e.y)
            v = self._snapv(v, 0.02)
            self._setp("rows_top_y_pct", v)
            self.refresh(); return

        if kind == "splitter":
            # adjust plot width by dragging splitter horizontally
            il, it, ir, ib = self._inner_rect()
            total_w = ir - il
            # clamp inside inner rect
            x = max(il + total_w * 0.2, min(ir - total_w * 0.2, e.x))
            left_w = x - il
            right_frac = 1.0 - (left_w / total_w)
            plotw = int(round(right_frac * 100))
            plotw = max(30, min(80, plotw))
            self._setp("plot_width_pct", plotw)
            self.refresh(); return

        if kind in ("logo_box", "logo_resize"):
            il, it, ir, ib = self._inner_rect()
            # current box
            x1, y1, x2, y2 = self.canvas.coords(self.items["logo_box"])
            if kind == "logo_box":
                # move
                nx1 = max(il, min(ir, x1 + dx))
                ny1 = max(it, min(ib, y1 + dy))
                w = x2 - x1; h = y2 - y1
                nx2 = max(il, min(ir, nx1 + w))
                ny2 = max(it, min(ib, ny1 + h))
            else:
                # resize from bottom-right
                nx1, ny1 = x1, y1
                nx2 = max(nx1 + 10, min(ir, x2 + dx))
                ny2 = max(ny1 + 10, min(ib, y2 + dy))
            # write back as pct
            x_pct = (nx1 - il) / (ir - il)
            y_pct = (ny1 - it) / (ib - it)
            w_pct = (nx2 - nx1) / (ir - il)
            h_pct = (ny2 - ny1) / (ib - it)
            # snap
            step = 0.01
            x_pct = self._snapv(x_pct, step); y_pct = self._snapv(y_pct, step)
            w_pct = self._snapv(w_pct, step); h_pct = self._snapv(h_pct, step)
            self._setp("logo_x_pct", x_pct)
            self._setp("logo_y_pct", y_pct)
            self._setp("logo_w_pct", w_pct)
            self._setp("logo_h_pct", max(0.0, h_pct))
            self.refresh(); return

    def _on_up(self, e):
        self.drag = {"item": None, "kind": None, "dx": 0, "dy": 0, "anchor": None}

    def _on_line_h_change(self):
        self._setp("line_height_pct", float(self.line_h_var.get()))
        self.refresh()

    def _on_graph_margin_change(self):
        self._setp("graph_margin_pct", int(self.graph_margin_var.get()))
        self.refresh()

    def reset_layout(self):
        # Reasonable defaults
        self._setp("title_x_pct", 0.0)
        self._setp("title_y_pct", 0.96)
        self._setp("static_text_x_pct", 0.0)
        self._setp("static_text_y_pct", 0.86)
        self._setp("labels_x_pct", 0.0)
        # If values_x_pct absent, renderer uses gap; here we set it explicitly near 0.6
        self._setp("values_x_pct", 0.6)
        self._setp("rows_top_y_pct", 0.78)
        self._setp("line_height_pct", 0.075)
        self._setp("graph_margin_pct", int(self._profile("margin_pct", 7)))
        # Keep current plot_width_pct; leave logo as-is
        self.refresh()

class App(ttk.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.master.title(APP_TITLE)
        self.pack(fill="both", expand=True)

        # State
        self.df: Optional[pd.DataFrame] = None
        self.xlsx_path: Optional[str] = None
        self.current_row_index: Optional[int] = None
        self.profile: Dict = default_profile(TEMPLATE_GRAPH)
        self.last_pdf: Optional[Path] = None

        # Vars that are referenced in multiple tabs — define early
        self.outdir_var = tk.StringVar(value=str(Path.cwd()))

        # Keep references to comboboxes
        self.slot_col_cbs: List[ttk.Combobox] = []
        self.g_slot_col_cbs: List[ttk.Combobox] = []

        # Autosave debounce
        self._autosave_after_id = None

        # Style
        self._init_style()

        # Notebook
        self.nb = ttk.Notebook(self)
        self.nb.pack(fill="both", expand=True, padx=8, pady=6)

        # Build tabs: Profile, Bindings, Actions, Data Source (last)
        self._build_tab_profiles()
        self._build_tab_bindings()
        self._build_tab_actions()
        self._build_tab_data()

        # Status
        self.status_var = tk.StringVar(value="")
        status = ttk.Label(self, textvariable=self.status_var, relief="sunken", anchor="w")
        status.pack(fill="x", padx=0, pady=(2, 0), ipady=2)

        # Profiles list
        self._refresh_profile_list()

        # Auto-load a profile at startup, if one exists
        try:
            names = list_profiles()
            pref = self.profile.get("profile_name")
            if pref and pref in names:
                self.profile_pick_var.set(pref)
                self._load_selected_profile()
            elif names:
                self.profile_pick_var.set(names[0])
                self._load_selected_profile()
        except Exception:
            pass

        self.master.protocol("WM_DELETE_WINDOW", self.on_close)

    def _clamp_inch(self, val, default):
        """
        Convert val to float and clamp to a safe printable range [0.5, 24.0] inches.
        Falls back to default on bad input.
        """
        try:
            v = float(val)
        except Exception:
            try:
                v = float(default)
            except Exception:
                v = 1.0
        if not (np.isfinite(v)):
            v = float(default) if isinstance(default, (int, float)) else 1.0
        return max(0.5, min(24.0, float(v)))
    
    def _init_style(self):
        style = ttk.Style()
        try:
            style.theme_use("clam")
        except Exception:
            pass
        style.configure("TLabel", padding=2)
        style.configure("TButton", padding=4)
        style.configure("TLabelframe", padding=6)
        style.configure("TLabelframe.Label", font=("Segoe UI", 10, "bold"))
        # Header label style: bigger, bold
        try:
            style.configure("ProfileHeader.TLabel", font=("Segoe UI", 14, "bold"))
        except Exception:
            pass


    def _make_profile_header(self, parent) -> ttk.Label:
        """
        Create a bold, large header showing the current profile name on a given tab.
        The label is registered so future name changes update everywhere.
        """
        if not hasattr(self, "_profile_header_labels"):
            self._profile_header_labels = []
        text = f"Profile: {self.profile.get('profile_name', 'Profile')}"
        lbl = ttk.Label(parent, text=text, style="ProfileHeader.TLabel")
        lbl.pack(fill="x", padx=10, pady=(8, 4))
        self._profile_header_labels.append(lbl)
        return lbl

    def _update_profile_header(self):
        """
        Update all header labels to reflect the current profile name.
        Safe if called before labels exist.
        """
        try:
            name = ""
            if hasattr(self, "profile_name_var") and self.profile_name_var is not None:
                name = (self.profile_name_var.get() or "").strip()
            if not name:
                name = self.profile.get("profile_name", "Profile")
            text = f"Profile: {name}"
            for lbl in getattr(self, "_profile_header_labels", []):
                try:
                    lbl.config(text=text)
                except Exception:
                    pass
        except Exception:
            pass

    # ========== Data Source (last tab) ==========
    def _build_tab_data(self):
        tab = ttk.Frame(self.nb)
        self.nb.add(tab, text="Data Source")

        # Header (fixed)
        self._make_profile_header(tab)

        f = ttk.Frame(tab)
        f.pack(fill="x", padx=10, pady=10)

        ttk.Label(f, text="Excel file:").grid(row=0, column=0, sticky="w")
        self.xlsx_var = tk.StringVar(value=self.profile.get("data_source", {}).get("xlsx_path", ""))
        ttk.Entry(f, textvariable=self.xlsx_var, width=60).grid(row=0, column=1, sticky="we", padx=(6, 6))
        ttk.Button(f, text="Browse...", command=self.on_browse_excel).grid(row=0, column=2, sticky="w")

        ttk.Label(f, text="Sheet:").grid(row=1, column=0, sticky="w", pady=(8, 0))
        self.sheet_var = tk.StringVar(value=self.profile.get("data_source", {}).get("sheet", ""))
        self.sheet_menu = ttk.Combobox(f, textvariable=self.sheet_var, width=28, state="readonly")
        self.sheet_menu.grid(row=1, column=1, sticky="w", padx=(6, 6), pady=(8, 0))
        self.sheet_menu.bind("<<ComboboxSelected>>", lambda e: self._load_sheet())

        ttk.Label(f, text="Serial column:").grid(row=2, column=0, sticky="w", pady=(8, 0))
        self.serial_col_var = tk.StringVar(value=self.profile.get("data_source", {}).get("serial_col", ""))
        self.serial_col_menu = ttk.Combobox(f, textvariable=self.serial_col_var, width=28, state="readonly")
        self.serial_col_menu.grid(row=2, column=1, sticky="w", padx=(6, 6), pady=(8, 0))
        self.serial_col_menu.bind("<<ComboboxSelected>>", lambda e: self._refresh_serials())

        ttk.Label(f, text="Serial (row):").grid(row=3, column=0, sticky="w", pady=(8, 0))
        # Allow typing to jump/select by serial quickly
        self.serial_pick_var = tk.StringVar()
        self.serial_pick_menu = ttk.Combobox(f, textvariable=self.serial_pick_var, width=40, state="normal")
        self.serial_pick_menu.grid(row=3, column=1, sticky="w", padx=(6, 6), pady=(8, 0))
        self.serial_pick_menu.bind("<<ComboboxSelected>>", lambda e: self._select_row_by_serial())
        # Type-to-select handlers
        self.serial_pick_menu.bind("<KeyRelease>", self._on_serial_typed_data)
        self.serial_pick_menu.bind("<Return>", self._on_serial_typed_data)

        ttk.Button(f, text="Save Data Source", command=self.on_save_data_source).grid(row=4, column=1, sticky="e", pady=(8, 0))

        f.columnconfigure(1, weight=1)

    def on_save_data_source(self):
        try:
            self.profile.setdefault("data_source", {})
            if self.xlsx_var.get():
                self.profile["data_source"]["xlsx_path"] = self.xlsx_var.get()
            if self.sheet_var.get():
                self.profile["data_source"]["sheet"] = self.sheet_var.get()
            if self.serial_col_var.get():
                self.profile["data_source"]["serial_col"] = self.serial_col_var.get()
            if self.serial_pick_var.get():
                self.profile["data_source"]["last_serial"] = self.serial_pick_var.get()
            save_profile(self.profile)
            self._flash_message("Data source saved", 1200)
        except Exception as e:
            messagebox.showerror("Save Data Source", f"Failed to save data source: {e}")

    def on_browse_excel(self):
        path = filedialog.askopenfilename(
            title="Select Excel file",
            filetypes=[("Excel files", "*.xlsx *.xlsm *.xls"), ("All files", "*.*")]
        )
        if not path:
            return
        self.xlsx_path = path
        self.xlsx_var.set(path)
        self.profile.setdefault("data_source", {})
        self.profile["data_source"]["xlsx_path"] = path
        try:
            sheets = read_excel_sheet_names(path)
            self.sheet_menu["values"] = sheets
            if sheets:
                saved_sheet = self.profile.get("data_source", {}).get("sheet")
                self.sheet_var.set(saved_sheet if (saved_sheet in sheets) else sheets[0])
                self._load_sheet()
            self._set_status(f"Loaded: {path}")
            save_profile(self.profile)
        except Exception as e:
            messagebox.showerror("Error", f"Error reading Excel: {e}")
            self._set_status(f"Error reading Excel: {e}")

    def _load_sheet(self):
        if not (self.xlsx_var.get() or self.xlsx_path) or not self.sheet_var.get():
            return
        path = self.xlsx_var.get() or self.xlsx_path
        try:
            self.df = read_excel_sheet(path, self.sheet_var.get())
            self.profile.setdefault("data_source", {})
            self.profile["data_source"]["xlsx_path"] = path
            self.profile["data_source"]["sheet"] = self.sheet_var.get()

            cols = list(self.df.columns)
            self.serial_col_menu["values"] = cols
            guess = next((c for c in cols if "serial" in str(c).lower()), cols[0] if cols else "")
            saved_serial_col = self.profile.get("data_source", {}).get("serial_col")
            self.serial_col_var.set(saved_serial_col if saved_serial_col in cols else guess)

            # Populate serials and bindings, then make graph UI ready
            self._refresh_serials()
            self._ensure_graph_ui_ready()

            self._set_status(f"Loaded sheet: {self.sheet_var.get()} ({len(self.df)} rows, {len(self.df.columns)} cols)")
            save_profile(self.profile)
        except Exception as e:
            self.df = None
            messagebox.showerror("Error", f"Error loading sheet: {e}")
            self._set_status(f"Error loading sheet: {e}")

    def _render_selected_cols_view(self):
        """
        Render selected Flow columns (X) top-to-bottom into the read-only text panel
        to the right of the listbox.
        """
        try:
            if not hasattr(self, "selected_cols_text") or not hasattr(self, "list_cols"):
                return
            sel_names = []
            try:
                sel_indices = list(self.list_cols.curselection())
                for i in sel_indices:
                    sel_names.append(self.list_cols.get(i))
            except Exception:
                sel_names = []

            # Update text content
            self.selected_cols_text.configure(state="normal")
            self.selected_cols_text.delete("1.0", "end")
            if sel_names:
                self.selected_cols_text.insert("1.0", "\n".join(sel_names))
            else:
                self.selected_cols_text.insert("1.0", "(none)")
            self.selected_cols_text.configure(state="disabled")
        except Exception:
            pass


    def _refresh_serials(self):
        if self.df is None or not self.serial_col_var.get():
            self.serial_pick_menu["values"] = []
            # also clear profile tab serial values
            try:
                self._update_profile_serial_menu_values([])
            except Exception:
                pass
            return
        col = self.serial_col_var.get()
        try:
            serials = [str(s).strip() for s in self.df[col].astype(str).fillna("").tolist()]
            seen, dedup = set(), []
            for s in serials:
                if s not in seen:
                    seen.add(s)
                    dedup.append(s)
            self.serial_pick_menu["values"] = dedup
            # keep Profile tab serial combo in sync
            try:
                self._update_profile_serial_menu_values(dedup)
            except Exception:
                pass
            if dedup:
                # prefer persisted last_serial if available; else last value
                last = (self.profile.get("data_source", {}) or {}).get("last_serial")
                pick = last if (last in dedup) else dedup[-1]
                self.serial_pick_var.set(pick)
                self.profile.setdefault("data_source", {})["last_serial"] = pick
                try:
                    save_profile(self.profile)
                except Exception:
                    pass
                self._select_row_by_serial()
        except Exception:
            pass

    def _select_row_by_serial(self):
        if self.df is None or not self.serial_col_var.get() or not self.serial_pick_var.get():
            return
        serial = self.serial_pick_var.get().strip()
        col = self.serial_col_var.get()
        dff = self.df[self.df[col].astype(str).str.strip() == serial]
        if len(dff) == 0:
            self.current_row_index = None
            self._set_status("Serial not found in current sheet.")
            return
        self.current_row_index = dff.index[-1]
        self.profile.setdefault("data_source", {})["serial_col"] = col
        save_profile(self.profile)
        self._set_status(f"Selected row index: {self.current_row_index}")

    # ========== Profile tab ==========
    def _build_tab_profiles(self):
        tab = ttk.Frame(self.nb)
        self.nb.add(tab, text="Profile")

        # Header (fixed, non-scrolling)
        self._make_profile_header(tab)

        # Make everything below the header scrollable
        sf = ScrollableFrame(tab)
        sf.pack(fill="both", expand=True, padx=6, pady=6)
        container = sf.scrollable_frame

        f = ttk.Frame(container); f.pack(fill="x", padx=10, pady=10)

        ttk.Label(f, text="Profile:").grid(row=0, column=0, sticky="w")
        self.profile_pick_var = tk.StringVar()
        self.profile_pick_menu = ttk.Combobox(f, textvariable=self.profile_pick_var, width=40, state="readonly")
        self.profile_pick_menu.grid(row=0, column=1, sticky="we", padx=(6, 6))
        self.profile_pick_menu.bind("<<ComboboxSelected>>", lambda e: self._load_selected_profile())

        ttk.Button(f, text="New", command=self._new_profile).grid(row=0, column=2, padx=(4, 0))

        ttk.Label(f, text="Name:").grid(row=1, column=0, sticky="w", pady=(8, 0))
        self.profile_name_var = tk.StringVar(value=self.profile.get("profile_name"))
        ttk.Entry(f, textvariable=self.profile_name_var, width=40).grid(row=1, column=1, sticky="w", padx=(6, 6), pady=(8, 0))

        ttk.Button(f, text="Save", command=self.on_save_profile).grid(row=1, column=2, pady=(8, 0))
        ttk.Button(f, text="Save As...", command=self.on_save_as_profile).grid(row=1, column=3, pady=(8, 0))
        ttk.Button(f, text="Delete", command=self.on_delete_profile).grid(row=1, column=4, pady=(8, 0))

        # Profile tab Serial (row) picker (mirrors Data Source tab)
        ttk.Label(f, text="Serial (row):").grid(row=2, column=0, sticky="w", pady=(8, 0))
        self.profile_serial_pick_var = tk.StringVar()
        self.profile_serial_pick_menu = ttk.Combobox(f, textvariable=self.profile_serial_pick_var, width=40, state="normal")
        self.profile_serial_pick_menu.grid(row=2, column=1, sticky="w", padx=(6, 6), pady=(8, 0))
        self.profile_serial_pick_menu.bind("<<ComboboxSelected>>", lambda e: self._on_profile_tab_serial_selected())
        self.profile_serial_pick_menu.bind("<KeyRelease>", self._on_serial_typed_profile)
        self.profile_serial_pick_menu.bind("<Return>", self._on_serial_typed_profile)

        f.columnconfigure(1, weight=1)

        # -- Template & Layout --
        tf = ttk.LabelFrame(container, text="Template & Layout")
        tf.pack(fill="x", padx=10, pady=(6, 10))

        # === Mode & Size (clamped) ===
        try:
            self.profile["label_w_in"] = self._clamp_inch(self.win_var.get(), self.profile.get("label_w_in", 3.0))
        except Exception:
            pass
        try:
            self.profile["label_h_in"] = self._clamp_inch(self.hin_var.get(), self.profile.get("label_h_in", 4.0))
        except Exception:
            pass
        try:
            self.profile["margin_pct"] = int(self.margin_var.get())
        except Exception:
            pass
        try:
            self.profile["text_scale_pct"] = int(self.text_scale_var.get())
        except Exception:
            pass
        try:
            # Keep your existing bounds elsewhere if needed; this just records the value
            self.profile["plot_width_pct"] = int(self.plotw_var.get())
        except Exception:
            pass

        # Title section
        titlef = ttk.LabelFrame(container, text="Title")
        titlef.pack(fill="x", padx=10, pady=(0, 6))
        ttk.Label(titlef, text="Color:").grid(row=0, column=0, sticky="e")
        self.title_color_var = tk.StringVar(value=self.profile.get("title_color", DEFAULT_TITLE_COLOR))
        ttk.Entry(titlef, textvariable=self.title_color_var, width=12).grid(row=0, column=1, sticky="w", padx=(6, 6))
        ttk.Button(titlef, text="Pick…", command=lambda: self._choose_color(self.title_color_var)).grid(row=0, column=2, sticky="w")

        ttk.Label(titlef, text="Text size:").grid(row=0, column=3, sticky="e")
        self.title_size_var = tk.IntVar(value=int(self.profile.get("title_font_size", 16)))
        ttk.Spinbox(titlef, from_=8, to=72, increment=1, textvariable=self.title_size_var, width=6, justify="right").grid(row=0, column=4, sticky="w", padx=(6, 12))

        ttk.Label(titlef, text="Vertical position (Y %):").grid(row=0, column=5, sticky="e")
        self.title_y_pct_var = tk.DoubleVar(value=float(self.profile.get("title_y_pct", 96.0)))
        ttk.Spinbox(titlef, from_=0.0, to=100.0, increment=0.5, textvariable=self.title_y_pct_var, width=8, justify="right").grid(row=0, column=6, sticky="w", padx=(6, 12))

        # Subtitle section
        subf = ttk.LabelFrame(container, text="Subtitle")
        subf.pack(fill="x", padx=10, pady=(0, 6))
        ttk.Label(subf, text="Color:").grid(row=0, column=0, sticky="e")
        self.subtitle_color_var = tk.StringVar(value=self.profile.get("subtitle_color", "#333333"))
        ttk.Entry(subf, textvariable=self.subtitle_color_var, width=12).grid(row=0, column=1, sticky="w", padx=(6, 6))
        ttk.Button(subf, text="Pick…", command=lambda: self._choose_color(self.subtitle_color_var)).grid(row=0, column=2, sticky="w")

        ttk.Label(subf, text="Text size:").grid(row=0, column=3, sticky="e")
        self.subtitle_size_var = tk.IntVar(value=int(self.profile.get("subtitle_font_size", 12)))
        ttk.Spinbox(subf, from_=8, to=48, increment=1, textvariable=self.subtitle_size_var, width=6, justify="right").grid(row=0, column=4, sticky="w", padx=(6, 12))

        ttk.Label(subf, text="Vertical position (Y %):").grid(row=0, column=5, sticky="e")
        self.subtitle_y_pct_var = tk.DoubleVar(value=float(self.profile.get("subtitle_y_pct", 86.0)))
        ttk.Spinbox(subf, from_=0.0, to=100.0, increment=0.5, textvariable=self.subtitle_y_pct_var, width=8, justify="right").grid(row=0, column=6, sticky="w", padx=(6, 12))

        # Labels section
        labf = ttk.LabelFrame(container, text="Labels")
        labf.pack(fill="x", padx=10, pady=(0, 6))
        ttk.Label(labf, text="Color:").grid(row=0, column=0, sticky="e")
        self.labels_color_var = tk.StringVar(value=self.profile.get("labels_color", "#333333"))
        ttk.Entry(labf, textvariable=self.labels_color_var, width=12).grid(row=0, column=1, sticky="w", padx=(6, 6))
        ttk.Button(labf, text="Pick…", command=lambda: self._choose_color(self.labels_color_var)).grid(row=0, column=2, sticky="w")

        ttk.Label(labf, text="Text size:").grid(row=0, column=3, sticky="e")
        self.labels_size_var = tk.IntVar(value=int(self.profile.get("labels_font_size", 11)))
        ttk.Spinbox(labf, from_=8, to=36, increment=1, textvariable=self.labels_size_var, width=6, justify="right").grid(row=0, column=4, sticky="w", padx=(6, 12))

        ttk.Label(labf, text="Top row Y %:").grid(row=0, column=5, sticky="e")
        self.rows_top_y_pct_var = tk.DoubleVar(value=float(self.profile.get("rows_top_y_pct", 78.0)))
        ttk.Spinbox(labf, from_=0.0, to=100.0, increment=0.5, textvariable=self.rows_top_y_pct_var, width=8, justify="right").grid(row=0, column=6, sticky="w", padx=(6, 12))

        ttk.Label(labf, text="Line height %:").grid(row=1, column=0, sticky="e", pady=(6, 0))
        self.line_height_pct_var = tk.DoubleVar(value=float(self.profile.get("line_height_pct", 7.5)))
        ttk.Spinbox(labf, from_=3.0, to=15.0, increment=0.5, textvariable=self.line_height_pct_var, width=8, justify="right").grid(row=1, column=1, sticky="w", padx=(6, 12), pady=(6, 0))

        ttk.Label(labf, text="Label/Value gap %:").grid(row=1, column=3, sticky="e", pady=(6, 0))
        self.label_value_gap_pct_var = tk.DoubleVar(value=float(self.profile.get("label_value_gap_pct", 10.0)))
        ttk.Spinbox(labf, from_=0.0, to=40.0, increment=0.5, textvariable=self.label_value_gap_pct_var, width=8, justify="right").grid(row=1, column=4, sticky="w", padx=(6, 12), pady=(6, 0))

        # Values section
        valf = ttk.LabelFrame(container, text="Label Values")
        valf.pack(fill="x", padx=10, pady=(0, 6))
        ttk.Label(valf, text="Color:").grid(row=0, column=0, sticky="e")
        self.values_color_var = tk.StringVar(value=self.profile.get("values_color", "#000000"))
        ttk.Entry(valf, textvariable=self.values_color_var, width=12).grid(row=0, column=1, sticky="w", padx=(6, 6))
        ttk.Button(valf, text="Pick…", command=lambda: self._choose_color(self.values_color_var)).grid(row=0, column=2, sticky="w")

        ttk.Label(valf, text="Text size:").grid(row=0, column=3, sticky="e")
        self.values_size_var = tk.IntVar(value=int(self.profile.get("values_font_size", 11)))
        ttk.Spinbox(valf, from_=8, to=36, increment=1, textvariable=self.values_size_var, width=6, justify="right").grid(row=0, column=4, sticky="w", padx=(6, 12))

        # Graph Axis section (only meaningful when graph is ON)
        axf = ttk.LabelFrame(container, text="Graph Axis & Line")
        axf.pack(fill="x", padx=10, pady=(0, 6))
        ttk.Label(axf, text="Axis label size:").grid(row=0, column=0, sticky="e")
        self.axis_label_size_var = tk.IntVar(value=int(self.profile.get("axis_label_font_size", 8)))
        ttk.Spinbox(axf, from_=6, to=24, increment=1, textvariable=self.axis_label_size_var, width=6, justify="right").grid(row=0, column=1, sticky="w", padx=(6, 12))

        ttk.Label(axf, text="Axis tick size:").grid(row=0, column=2, sticky="e")
        self.axis_tick_size_var = tk.IntVar(value=int(self.profile.get("axis_tick_font_size", 6)))
        ttk.Spinbox(axf, from_=6, to=20, increment=1, textvariable=self.axis_tick_size_var, width=6, justify="right").grid(row=0, column=3, sticky="w", padx=(6, 12))

        ttk.Label(axf, text="Axis color:").grid(row=0, column=4, sticky="e")
        self.axis_color_var = tk.StringVar(value=self.profile.get("axis_color", "#666666"))
        ttk.Entry(axf, textvariable=self.axis_color_var, width=10).grid(row=0, column=5, sticky="w", padx=(6, 6))
        ttk.Button(axf, text="Pick…", command=lambda: self._choose_color(self.axis_color_var)).grid(row=0, column=6, sticky="w")

        ttk.Label(axf, text="Graph line color:").grid(row=1, column=0, sticky="e", pady=(6, 0))
        self.graph_line_color_var = tk.StringVar(value=self.profile.get("graph_line_color", "#1F77B4"))
        ttk.Entry(axf, textvariable=self.graph_line_color_var, width=10).grid(row=1, column=1, sticky="w", padx=(6, 6), pady=(6, 0))
        ttk.Button(axf, text="Pick…", command=lambda: self._choose_color(self.graph_line_color_var)).grid(row=1, column=2, sticky="w", pady=(6, 0))

        self.grid_enabled_var = tk.BooleanVar(value=bool(self.profile.get("grid_enabled", True)))
        ttk.Checkbutton(axf, text="Show grid", variable=self.grid_enabled_var).grid(row=1, column=3, sticky="w", pady=(6, 0))

        # Logo section (applies with or without graph)
        logof = ttk.LabelFrame(container, text="Logo (applies to all templates)")
        logof.pack(fill="x", padx=10, pady=(0, 10))
        self.logo_enabled_var = tk.BooleanVar(value=bool(self.profile.get("logo_enabled", False)))
        ttk.Checkbutton(logof, text="Include logo", variable=self.logo_enabled_var).grid(row=0, column=0, sticky="w")

        ttk.Label(logof, text="Path:").grid(row=0, column=1, sticky="e")
        self.tpl_logo_path_var = tk.StringVar(value=self.profile.get("bindings", {}).get("logo_path", ""))  # keep compatibility
        ttk.Entry(logof, textvariable=self.tpl_logo_path_var, width=48).grid(row=0, column=2, columnspan=2, sticky="w", padx=(6, 6))
        ttk.Button(logof, text="Browse…", command=self._browse_logo).grid(row=0, column=4, sticky="w")

        ttk.Label(logof, text="Vertical position (Y %):").grid(row=1, column=0, sticky="e", pady=(6, 0))
        self.logo_y_pct_var = tk.DoubleVar(value=float(self.profile.get("logo_y_pct", 70.0)))
        ttk.Spinbox(logof, from_=0.0, to=100.0, increment=0.5, textvariable=self.logo_y_pct_var, width=8, justify="right").grid(row=1, column=1, sticky="w", padx=(6, 12), pady=(6, 0))

        ttk.Label(logof, text="Width % (of label):").grid(row=1, column=2, sticky="e", pady=(6, 0))
        self.logo_w_pct_var = tk.DoubleVar(value=float(self.profile.get("logo_w_pct", 28.0)))
        ttk.Spinbox(logof, from_=5.0, to=80.0, increment=0.5, textvariable=self.logo_w_pct_var, width=8, justify="right").grid(row=1, column=3, sticky="w", padx=(6, 12), pady=(6, 0))

        ttk.Label(logof, text="Align:").grid(row=1, column=4, sticky="e", pady=(6, 0))
        self.logo_align_var = tk.StringVar(value=self.profile.get("logo_align", "left"))
        ttk.Combobox(logof, textvariable=self.logo_align_var, state="readonly", values=["left", "center", "right"], width=8).grid(row=1, column=5, sticky="w", pady=(6, 0))

        # Output (inside scroll area)
        of = ttk.LabelFrame(container, text="Output")
        of.pack(fill="x", padx=10, pady=(6, 10))

        ttk.Label(of, text="Output target:").grid(row=0, column=0, sticky="w")
        self.target_var = tk.StringVar(value=self.profile.get("output_target", TARGET_LX900_3x4))
        target_menu = ttk.Combobox(of, textvariable=self.target_var,
                                values=[TARGET_LETTER_TWO_UP, TARGET_LX900_3x4],
                                width=24, state="readonly")
        target_menu.grid(row=0, column=1, sticky="w", padx=(6, 12))

        ttk.Label(of, text="Filename pattern:").grid(row=1, column=0, sticky="w", pady=(8, 0))
        self.fnp_var = tk.StringVar(value=self.profile.get("filename_pattern", "{serial}_{profile}.pdf"))
        ttk.Entry(of, textvariable=self.fnp_var, width=48).grid(row=1, column=1, sticky="w", padx=(6, 12), pady=(8, 0))

        ttk.Label(of, text="Copies:").grid(row=2, column=0, sticky="w", pady=(8, 0))
        self.copies_var = tk.IntVar(value=int(self.profile.get("copies", 1)))
        ttk.Spinbox(of, from_=1, to=50, increment=1, textvariable=self.copies_var, width=6, justify="right").grid(row=2, column=1, sticky="w", padx=(6, 12), pady=(8, 0))

        self.open_after_var = tk.BooleanVar(value=bool(self.profile.get("open_after", True)))
        ttk.Checkbutton(of, text="Open after export", variable=self.open_after_var).grid(row=3, column=1, sticky="w", pady=(8, 0))

        ttk.Label(of, text="Output folder:").grid(row=4, column=0, sticky="w", pady=(8, 0))
        self.outdir_var = getattr(self, "outdir_var", tk.StringVar(value=str(Path.cwd())))
        ttk.Entry(of, textvariable=self.outdir_var, width=54).grid(row=4, column=1, sticky="w", padx=(6, 12), pady=(8, 0))
        ttk.Button(of, text="Browse...", command=self._browse_outdir).grid(row=4, column=2, sticky="w", pady=(8, 0))

        # Traces and initial sync
        self._attach_profile_traces()
        self._sync_profile_to_ui()
        self._ensure_graph_ui_ready()
    
    # ========== Bindings tab ==========
    def _build_tab_bindings(self):
        tab = ttk.Frame(self.nb)
        self.nb.add(tab, text="Bindings")

        # Header (fixed, non-scrolling)
        self._make_profile_header(tab)

        sf = ScrollableFrame(tab)
        sf.pack(fill="both", expand=True, padx=6, pady=6)

        # Action row
        action_row = ttk.Frame(sf.scrollable_frame)
        action_row.pack(fill="x", padx=10, pady=(4, 2))
        ttk.Button(action_row, text="Save Bindings", command=self.on_save_bindings).pack(side="right")
        ttk.Label(action_row, text="(Pick flow columns and slot columns, then Save Bindings)").pack(side="right", padx=(0, 8))

        # Graph bindings
        self.bind_graph = ttk.LabelFrame(sf.scrollable_frame, text="Graph Bindings")
        self.bind_graph.pack(fill="x", padx=10, pady=6)

        self.bg_title_var = tk.StringVar(value=self.profile.get("bindings", {}).get("title", "Neb Label"))
        self.bg_inc_trend_var = tk.BooleanVar(value=bool(self.profile.get("bindings", {}).get("include_trendline", True)))
        ttk.Label(self.bind_graph, text="Title:").grid(row=0, column=0, sticky="w")
        ttk.Entry(self.bind_graph, textvariable=self.bg_title_var, width=36).grid(row=0, column=1, sticky="w", padx=(6, 12))
        ttk.Checkbutton(self.bind_graph, text="Include trendline", variable=self.bg_inc_trend_var).grid(row=0, column=2, sticky="w")

        ttk.Label(self.bind_graph, text="Flow columns (X):").grid(row=1, column=0, sticky="nw", pady=(8, 0))
        self.list_cols = tk.Listbox(self.bind_graph, selectmode="multiple", width=48, height=12, exportselection=False)
        try:
            self.list_cols.configure(selectbackground="#0E6CD6", selectforeground="white")
        except Exception:
            pass
        self.list_cols.grid(row=1, column=1, columnspan=3, sticky="w", padx=(6, 0), pady=(8, 0))

        # Right-side selected text panel (top-to-bottom)
        sel_panel = ttk.Frame(self.bind_graph)
        sel_panel.grid(row=1, column=4, sticky="nw", padx=(12, 0), pady=(8, 0))
        ttk.Label(sel_panel, text="Selected (top to bottom):").pack(anchor="w")
        self.selected_cols_text = tk.Text(sel_panel, width=28, height=12, wrap="none")
        self.selected_cols_text.configure(state="disabled")
        self.selected_cols_text.pack(fill="both", expand=False, pady=(4, 0))

        self.list_cols.bind("<<ListboxSelect>>", lambda e: (self._on_profile_field_change(), self._render_selected_cols_view()))

        # Graph: Value slots (optional) — dynamic count
        ttk.Label(self.bind_graph, text="Value Slots (optional):").grid(row=3, column=0, sticky="w", pady=(10, 2))
        self.g_slot_label_vars = []
        self.g_slot_col_vars = []
        self.g_slot_col_cbs = []

        slots_count = int(self.profile.get("template", {}).get("slots_count", 10))
        row = 4
        for i in range(1, slots_count + 1):
            labv = tk.StringVar()
            colv = tk.StringVar()
            self.g_slot_label_vars.append(labv)
            self.g_slot_col_vars.append(colv)
            ttk.Label(self.bind_graph, text=f"Label {i}:").grid(row=row, column=0, sticky="w")
            ent = ttk.Entry(self.bind_graph, textvariable=labv, width=24)
            ent.grid(row=row, column=1, sticky="w", padx=(6, 12))
            ent.bind("<FocusOut>", lambda e: self._on_profile_field_change())
            ttk.Label(self.bind_graph, text=f"Value {i} column:").grid(row=row, column=2, sticky="w")
            cb = ttk.Combobox(self.bind_graph, textvariable=colv, width=24, state="readonly")
            cb.grid(row=row, column=3, sticky="w", padx=(6, 12))
            cb.bind("<<ComboboxSelected>>", lambda e, idx=i: self._on_profile_field_change())
            self.g_slot_col_cbs.append(cb)
            row += 1

        # Value bindings (non-graph)
        self.bind_values = ttk.LabelFrame(sf.scrollable_frame, text="Value Bindings")
        self.bv_title_var = tk.StringVar()
        self.bv_subtitle_var = tk.StringVar()
        self.bv_logo_var = tk.StringVar()

        row = 0
        ttk.Label(self.bind_values, text="Title:").grid(row=row, column=0, sticky="w"); row += 1
        e = ttk.Entry(self.bind_values, textvariable=self.bv_title_var, width=36)
        e.grid(row=row-1, column=1, sticky="w", padx=(6, 12))
        e.bind("<FocusOut>", lambda ev: self._on_profile_field_change())

        ttk.Label(self.bind_values, text="Subtitle:").grid(row=row, column=0, sticky="w"); row += 1
        e2 = ttk.Entry(self.bind_values, textvariable=self.bv_subtitle_var, width=36)
        e2.grid(row=row-1, column=1, sticky="w", padx=(6, 12))
        e2.bind("<FocusOut>", lambda ev: self._on_profile_field_change())

        ttk.Label(self.bind_values, text="Logo path:").grid(row=row, column=0, sticky="w"); row += 1
        le = ttk.Entry(self.bind_values, textvariable=self.bv_logo_var, width=48)
        le.grid(row=row-1, column=1, sticky="w", padx=(6, 6))
        ttk.Button(self.bind_values, text="Browse...", command=self._browse_logo).grid(row=row-1, column=2, sticky="w")
        le.bind("<FocusOut>", lambda ev: self._on_profile_field_change())

        self.slot_label_vars = []
        self.slot_col_vars = []
        self.slot_col_cbs = []

        slots_count = int(self.profile.get("template", {}).get("slots_count", 10))
        for i in range(1, slots_count + 1):
            labv = tk.StringVar()
            colv = tk.StringVar()
            self.slot_label_vars.append(labv)
            self.slot_col_vars.append(colv)
            ttk.Label(self.bind_values, text=f"Label {i}:").grid(row=row, column=0, sticky="w")
            ent = ttk.Entry(self.bind_values, textvariable=labv, width=24)
            ent.grid(row=row, column=1, sticky="w", padx=(6, 12))
            ent.bind("<FocusOut>", lambda e: self._on_profile_field_change())
            ttk.Label(self.bind_values, text=f"Value {i} column:").grid(row=row, column=2, sticky="w")
            cb = ttk.Combobox(self.bind_values, textvariable=colv, width=24, state="readonly")
            cb.grid(row=row, column=3, sticky="w", padx=(6, 12))
            cb.bind("<<ComboboxSelected>>", lambda e, idx=i: self._on_profile_field_change())
            self.slot_col_cbs.append(cb)
            row += 1

        self._toggle_binding_panels()
        self._refresh_binding_columns()
        try:
            self._render_selected_cols_view()
        except Exception:
            pass
        
    def _ensure_graph_ui_ready(self):
        """
        Ensure the graph-related UI is fully initialized and interactive.
        Call after profiles/sheets load, when creating new profile, or when include_graph flips.
        """
        try:
            self._refresh_binding_columns()
        except Exception:
            pass
        try:
            self._toggle_binding_panels()
        except Exception:
            pass
        try:
            self._update_graph_controls_visibility()
        except Exception:
            pass
        try:
            if hasattr(self, "layout_editor") and self.layout_editor is not None:
                self.layout_editor.refresh()
        except Exception:
            pass
        try:
            if hasattr(self, "_render_selected_cols_view"):
                self._render_selected_cols_view()
        except Exception:
            pass
    
    def _match_serial_value(self, text: str, values: List[str]) -> Optional[str]:
        """
        Return the best matching serial from values for the typed text.
        Priority: exact match (case insensitive) > startswith (case insensitive) > contains.
        """
        if not text:
            return None
        t = text.strip().lower()
        if not t:
            return None
        # Exact
        for v in values:
            if v.lower() == t:
                return v
        # Startswith
        for v in values:
            if v.lower().startswith(t):
                return v
        # Contains
        for v in values:
            if t in v.lower():
                return v
        return None

    def _on_serial_typed_data(self, event=None):
        """
        Type-to-select for the Data Source tab serial combobox with true autocomplete.
        """
        try:
            values = list(self.serial_pick_menu["values"]) if hasattr(self, "serial_pick_menu") else []
            self._autocomplete_serial(self.serial_pick_menu, self.serial_pick_var, values, event, mirror_var=getattr(self, "profile_serial_pick_var", None))
        except Exception:
            pass

    def _on_serial_typed_profile(self, event=None):
        """
        Type-to-select for the Profile tab serial combobox with true autocomplete.
        """
        try:
            values = list(self.profile_serial_pick_menu["values"]) if hasattr(self, "profile_serial_pick_menu") else []
            self._autocomplete_serial(self.profile_serial_pick_menu, self.profile_serial_pick_var, values, event, mirror_var=getattr(self, "serial_pick_var", None))
        except Exception:
            pass

    def _commit_serial_selection(self, serial_value: str):
        """
        Commit the chosen serial across both tabs, select the row, and persist last_serial.
        """
        try:
            # Mirror into both combobox variables if present
            if hasattr(self, "serial_pick_var") and self.serial_pick_var is not None:
                self.serial_pick_var.set(serial_value)
            if hasattr(self, "profile_serial_pick_var") and self.profile_serial_pick_var is not None:
                self.profile_serial_pick_var.set(serial_value)

            # Select row in DataFrame (if possible)
            try:
                self._select_row_by_serial()
            except Exception:
                pass

            # Persist into profile
            try:
                self.profile.setdefault("data_source", {})["last_serial"] = serial_value
                save_profile(self.profile)
            except Exception:
                pass
            self._set_status(f"Serial selected: {serial_value}")
        except Exception:
            pass

    def _autocomplete_serial(self, combo: ttk.Combobox, var: tk.StringVar, values: List[str], event=None, mirror_var: Optional[tk.StringVar] = None):
        """
        Autocomplete behavior for a ttk.Combobox:
        - Live prefix match; falls back to contains if no prefix match.
        - Auto-fills with selected completion highlighted for continued typing.
        - Commit on Enter or exact match.
        """
        try:
            text = (var.get() or "")
            t = text.strip()
            vals = values or []
            if not t:
                return

            # Key handling: allow navigation keys to pass without changing content, but still
            # allow BackSpace/Delete to re-suggest based on the new typed prefix.
            nav_keys = {"Left", "Right", "Home", "End", "Prior", "Next"}  # page up/down, arrows
            commit_keys = {"Return", "KP_Enter"}
            if event is not None and event.keysym in nav_keys:
                return

            # Find best match: prefix first, then contains (case-insensitive)
            tl = t.lower()
            match = None

            # Prefix match
            for v in vals:
                if v.lower().startswith(tl):
                    match = v
                    break

            # Fallback to contains
            if not match:
                for v in vals:
                    if tl in v.lower():
                        match = v
                        break

            # If no match, do nothing further
            if not match:
                return

            # If Enter pressed or exact match typed, commit the selection
            if (event is not None and event.keysym in commit_keys) or (match.lower() == tl):
                self._commit_serial_selection(match)
                return

            # Otherwise, suggest by auto-filling and selecting the completion part
            combo.set(match)
            try:
                # Place cursor at end of the typed text; select the suggested tail
                combo.icursor(len(t))
                combo.selection_range(len(t), len(match))
            except Exception:
                pass

            # Do NOT commit yet; let the user continue typing or press Enter to commit
        except Exception:
            pass


    def _refresh_binding_columns(self):
        """
        Rebuild binding choices from self.df and re-apply saved selections.

        - Populates the Flow columns (X) listbox with current df columns.
        - Re-applies saved selections from profile['bindings']['x_flow_columns'].
        - Updates the right-side selected text panel.
        - Populates slot column comboboxes (graph and non-graph) with df columns,
        and re-applies saved selections that still exist.
        - Also re-applies the slot LABEL text into the entry fields so the user's
        typed labels remain visible after saving or toggling modes.
        - Adds an explicit '(none)' option for value-column comboboxes.
        - Defensive: safe if widgets or df are not yet available.
        """
        NONE_LABEL = "(none)"

        # 1) Collect column names from the loaded DataFrame
        try:
            cols = list(self.df.columns) if getattr(self, "df", None) is not None else []
        except Exception:
            cols = []
        cols_with_none = [NONE_LABEL] + cols

        # 2) Load saved bindings (defensive)
        try:
            b = self.profile.get("bindings", {}) if getattr(self, "profile", None) else {}
        except Exception:
            b = {}

        # 3) Flow columns listbox
        try:
            if hasattr(self, "list_cols") and self.list_cols is not None:
                # Refresh entries
                try:
                    self.list_cols.delete(0, tk.END)
                    for c in cols:
                        self.list_cols.insert(tk.END, c)
                except Exception:
                    pass

                # Re-apply saved selections (accept list or '|' separated string)
                saved = b.get("x_flow_columns", []) or []
                if isinstance(saved, str):
                    saved = [s.strip() for s in saved.split("|") if s.strip()]
                try:
                    self.list_cols.selection_clear(0, tk.END)
                except Exception:
                    pass

                try:
                    # Map saved names to current indices; ignore names not in current df
                    name_to_idx = {name: i for i, name in enumerate(cols)}
                    for name in saved:
                        idx = name_to_idx.get(name)
                        if idx is not None:
                            try:
                                self.list_cols.selection_set(idx)
                            except Exception:
                                pass
                except Exception:
                    pass
        except Exception:
            pass

        # 4) Graph slot combobox options and selections + label text (Value Slots under Graph Bindings)
        try:
            for cb in getattr(self, "g_slot_col_cbs", []) or []:
                try:
                    cb["values"] = cols_with_none
                except Exception:
                    pass

            # Determine how many graph slot rows we actually have in the UI (fixed 6 in this file)
            try:
                g_n = min(len(getattr(self, "g_slot_label_vars", []) or []),
                        len(getattr(self, "g_slot_col_vars", []) or []))
            except Exception:
                g_n = 0

            for i in range(g_n):
                idx = i + 1
                # Value column
                key_col = f"slot{idx}_col"
                val_col = (b.get(key_col, "") or "").strip()
                try:
                    if not val_col or val_col not in cols:
                        self.g_slot_col_vars[i].set(NONE_LABEL)
                    else:
                        self.g_slot_col_vars[i].set(val_col)
                except Exception:
                    pass

                # Label text
                key_lab = f"slot{idx}_label"
                val_lab = (b.get(key_lab, "") or "")
                try:
                    self.g_slot_label_vars[i].set(val_lab)
                except Exception:
                    pass
        except Exception:
            pass

        # 5) Non-graph (Value Bindings) slot combobox options/selections + label text
        try:
            for cb in getattr(self, "slot_col_cbs", []) or []:
                try:
                    cb["values"] = cols_with_none
                except Exception:
                    pass

            # Determine how many non-graph slot rows we have (fixed 6 in this file)
            try:
                n_n = min(len(getattr(self, "slot_label_vars", []) or []),
                        len(getattr(self, "slot_col_vars", []) or []))
            except Exception:
                n_n = 0

            for i in range(n_n):
                idx = i + 1
                # Value column
                key_col = f"slot{idx}_col"
                val_col = (b.get(key_col, "") or "").strip()
                try:
                    if not val_col or val_col not in cols:
                        self.slot_col_vars[i].set(NONE_LABEL)
                    else:
                        self.slot_col_vars[i].set(val_col)
                except Exception:
                    pass

                # Label text
                key_lab = f"slot{idx}_label"
                val_lab = (b.get(key_lab, "") or "")
                try:
                    self.slot_label_vars[i].set(val_lab)
                except Exception:
                    pass
        except Exception:
            pass

        # 6) Update the right-side selected view to match current listbox selection
        try:
            if hasattr(self, "_render_selected_cols_view"):
                self._render_selected_cols_view()
        except Exception:
            pass

        # 7) Reflect graph/value mode enable/disable states
        try:
            if hasattr(self, "_update_graph_controls_visibility"):
                self._update_graph_controls_visibility()
        except Exception:
            pass


    def _toggle_binding_panels(self):
        """
        Show/hide the correct bindings panel based on 'Include graph', and refresh
        controls so any saved labels/columns immediately populate the visible entries.
        """
        try:
            graph_mode = bool(self.include_graph_var.get())
        except Exception:
            graph_mode = False

        if graph_mode:
            if hasattr(self, "bind_values"):
                try: self.bind_values.pack_forget()
                except Exception: pass
            if hasattr(self, "bind_graph"):
                try: self.bind_graph.pack(fill="x", padx=10, pady=10)
                except Exception: pass
        else:
            if hasattr(self, "bind_graph"):
                try: self.bind_graph.pack_forget()
                except Exception: pass
            if hasattr(self, "bind_values"):
                try: self.bind_values.pack(fill="x", padx=10, pady=10)
                except Exception: pass

        # After switching panels, re-apply saved labels/columns into the now-visible entries
        try:
            self._refresh_binding_columns()
        except Exception:
            pass


    def on_save_bindings(self):
        """
        Save the current bindings (flow columns, slot labels/columns) to the active profile file.
        Shows a short confirmation, refreshes the selected columns view, and keeps the
        entry boxes populated with the saved values so the user sees their text stay.
        """
        try:
            # Ensure the latest UI selections are written into the profile dict
            self._on_profile_field_change(force_save=True)

            # Persist to disk
            save_profile(self.profile)

            # Re-apply bindings back into the UI so entries remain populated
            try:
                self._refresh_binding_columns()
            except Exception:
                pass

            # Refresh the visible right-side list
            try:
                if hasattr(self, "_render_selected_cols_view"):
                    self._render_selected_cols_view()
            except Exception:
                pass

            # Brief confirmation for the user
            try:
                self._flash_message("Bindings saved", 1500)
            except Exception:
                self._set_status("Bindings saved")
        except Exception as e:
            try:
                messagebox.showerror("Save Bindings", f"Failed to save bindings: {e}")
            except Exception:
                pass  
        
    # ========== Actions tab ==========
    def _build_tab_actions(self):
        tab = ttk.Frame(self.nb)
        self.nb.add(tab, text="Preview & Generate")

        # Header (fixed)
        self._make_profile_header(tab)

        f = ttk.Frame(tab); f.pack(fill="x", padx=10, pady=10)
        ttk.Button(f, text="Preview (current row)", command=self.on_preview).pack(side="left")
        ttk.Button(f, text="Generate PDF (current row)", command=self.on_generate).pack(side="left", padx=(10, 0))

    # ========== Debug helper ==========
    def _debug_print_profile_and_row(self, profile, df, row):
        try:
            import json, pprint
            print("---- DEBUG PROFILE ----")
            try:
                print(json.dumps(profile, indent=2, default=str)[:4000])
            except Exception:
                pprint.pprint(profile)
            print("---- DEBUG DF HEAD ----")
            try:
                print(df.head().to_string() if df is not None else "<df is None>")
            except Exception:
                print("<failed to print df head>")
            print("---- DEBUG ROW ----")
            try:
                print(row.to_dict() if row is not None else "<row is None>")
            except Exception:
                print("<failed to print row>")
            print("------------------------")
        except Exception:
            pass

    def _on_profile_tab_serial_selected(self):
        """
        Called when the serial is chosen from the Profile tab's Serial (row) combobox.
        Keeps the Data tab's serial selection in sync, selects the row, and persists last_serial.
        """
        try:
            s = (self.profile_serial_pick_var.get() or "").strip()
            if not s:
                return
            # mirror into Data Source tab serial picker if present
            if hasattr(self, "serial_pick_var") and self.serial_pick_var is not None:
                try:
                    self.serial_pick_var.set(s)
                except Exception:
                    pass
            # select row if possible (uses serial_pick_var and serial_col_var)
            try:
                self._select_row_by_serial()
            except Exception:
                pass
            # persist into profile
            self.profile.setdefault("data_source", {})["last_serial"] = s
            try:
                save_profile(self.profile)
            except Exception:
                pass
            self._set_status(f"Serial selected: {s}")
        except Exception:
            pass



    def _update_profile_serial_menu_values(self, serial_list: List[str]):
        """
        Update the Serial (row) combobox on the Profile tab with the provided values and select an appropriate default.
        """
        try:
            if not hasattr(self, "profile_serial_pick_menu") or self.profile_serial_pick_menu is None:
                return
            self.profile_serial_pick_menu["values"] = serial_list or []
            last = (self.profile.get("data_source", {}) or {}).get("last_serial")
            if last and last in (serial_list or []):
                self.profile_serial_pick_var.set(last)
            elif serial_list:
                # choose last available by default if nothing saved
                self.profile_serial_pick_var.set(serial_list[-1])
        except Exception:
            pass

    # ========== Profile/UI sync and autosave ==========
    
    def _attach_profile_traces(self):
        def _safe_add_trace(var, cb):
            try:
                if var is not None:
                    var.trace_add("write", cb)
            except Exception:
                pass

        # Basic/profile
        _safe_add_trace(getattr(self, "profile_name_var", None), lambda *a: (self._update_profile_header(), self._schedule_autosave()))
        for nm in ("xlsx_var","sheet_var","serial_col_var"):
            _safe_add_trace(getattr(self, nm, None), lambda *a: self._schedule_autosave())

        # Mode & Size
        for nm in ("win_var","hin_var","margin_var","text_scale_var","plotw_var","graph_margin_var"):
            _safe_add_trace(getattr(self, nm, None), lambda *a: self._schedule_autosave())

        # Title
        for nm in ("title_color_var","title_size_var","title_y_pct_var"):
            _safe_add_trace(getattr(self, nm, None), lambda *a: self._schedule_autosave())

        # Subtitle
        for nm in ("subtitle_color_var","subtitle_size_var","subtitle_y_pct_var"):
            _safe_add_trace(getattr(self, nm, None), lambda *a: self._schedule_autosave())

        # Labels and Values
        for nm in ("labels_color_var","labels_size_var","rows_top_y_pct_var","line_height_pct_var","label_value_gap_pct_var","values_color_var","values_size_var"):
            _safe_add_trace(getattr(self, nm, None), lambda *a: self._schedule_autosave())

        # Graph axis & line
        for nm in ("axis_label_size_var","axis_tick_size_var","axis_color_var","graph_line_color_var"):
            _safe_add_trace(getattr(self, nm, None), lambda *a: self._schedule_autosave())
        _safe_add_trace(getattr(self, "grid_enabled_var", None), lambda *a: self._schedule_autosave())

        # Logo
        for nm in ("logo_enabled_var","tpl_logo_path_var","logo_y_pct_var","logo_w_pct_var","logo_align_var"):
            _safe_add_trace(getattr(self, nm, None), lambda *a: self._schedule_autosave())

        # Output
        for nm in ("target_var","fnp_var","copies_var","open_after_var"):
            _safe_add_trace(getattr(self, nm, None), lambda *a: self._schedule_autosave())

        # Include graph toggling
        def _include_graph_cb(*_):
            try:
                self._toggle_binding_panels()
                self._update_graph_controls_visibility()
            except Exception:
                pass
            self._schedule_autosave()
        _safe_add_trace(getattr(self, "include_graph_var", None), _include_graph_cb)

        # Template text saves on focus-out (if present)
        try:
            if hasattr(self, "template_text") and getattr(self, "template_text") is not None:
                self.template_text.bind("<FocusOut>", lambda e: self._schedule_autosave())
        except Exception:
            pass

    def _update_selected_cols_label(self):
        """
        Update the 'Selected:' summary under the Flow columns listbox so the user
        always sees which columns are selected (even if the listbox isn't focused).
        """
        try:
            if not hasattr(self, "selected_cols_var"):
                return
            if hasattr(self, "list_cols") and self.list_cols is not None:
                sel = [self.list_cols.get(i) for i in self.list_cols.curselection()]
                self.selected_cols_var.set("Selected: " + (", ".join(sel) if sel else "(none)"))
        except Exception:
            # never raise from UI helper
            pass


    def _schedule_autosave(self, delay_ms: int = 400):
        # Debounce frequent edits
        try:
            if self._autosave_after_id:
                self.after_cancel(self._autosave_after_id)
        except Exception:
            pass
        self._autosave_after_id = self.after(delay_ms, lambda: self._on_profile_field_change())

    def _on_profile_field_change(self, force_save: bool = False):
        if not getattr(self, "profile", None):
            return

        # Name
        try:
            if getattr(self, "profile_name_var", None):
                self.profile["profile_name"] = self.profile_name_var.get().strip() or self.profile.get("profile_name")
        except Exception:
            pass

        # Template container
        self.profile.setdefault("template", {})
        tpl = self.profile["template"]

        # Mode & Size
        try: tpl["include_graph"] = bool(self.include_graph_var.get())
        except Exception: pass
        try: self.profile["label_w_in"] = float(self.win_var.get())
        except Exception: pass
        try: self.profile["label_h_in"] = float(self.hin_var.get())
        except Exception: pass
        try: self.profile["margin_pct"] = int(self.margin_var.get())
        except Exception: pass
        try: self.profile["text_scale_pct"] = int(self.text_scale_var.get())
        except Exception: pass
        try: self.profile["plot_width_pct"] = int(self.plotw_var.get())
        except Exception: pass
        try: self.profile["graph_margin_pct"] = int(self.graph_margin_var.get())
        except Exception: pass

        # Title
        try: self.profile["title_color"] = (self.title_color_var.get() or DEFAULT_TITLE_COLOR).strip()
        except Exception: pass
        try: self.profile["title_font_size"] = int(self.title_size_var.get())
        except Exception: pass
        try: self.profile["title_y_pct"] = float(self.title_y_pct_var.get())
        except Exception: pass

        # Subtitle (format only; text lives in bindings["subtitle"])
        try: self.profile["subtitle_color"] = (self.subtitle_color_var.get() or "#333333").strip()
        except Exception: pass
        try: self.profile["subtitle_font_size"] = int(self.subtitle_size_var.get())
        except Exception: pass
        try: self.profile["subtitle_y_pct"] = float(self.subtitle_y_pct_var.get())
        except Exception: pass

        # Labels / Values
        try: self.profile["labels_color"] = (self.labels_color_var.get() or "#333333").strip()
        except Exception: pass
        try: self.profile["labels_font_size"] = int(self.labels_size_var.get())
        except Exception: pass
        try: self.profile["rows_top_y_pct"] = float(self.rows_top_y_pct_var.get())
        except Exception: pass
        try: self.profile["line_height_pct"] = float(self.line_height_pct_var.get())
        except Exception: pass
        try: self.profile["label_value_gap_pct"] = float(self.label_value_gap_pct_var.get())
        except Exception: pass
        try: self.profile["values_color"] = (self.values_color_var.get() or "#000000").strip()
        except Exception: pass
        try: self.profile["values_font_size"] = int(self.values_size_var.get())
        except Exception: pass

        # Graph axis & line
        try: self.profile["axis_label_font_size"] = int(self.axis_label_size_var.get())
        except Exception: pass
        try: self.profile["axis_tick_font_size"] = int(self.axis_tick_size_var.get())
        except Exception: pass
        try: self.profile["axis_color"] = (self.axis_color_var.get() or "#666666").strip()
        except Exception: pass
        try: self.profile["graph_line_color"] = (self.graph_line_color_var.get() or "#1F77B4").strip()
        except Exception: pass
        try: self.profile["grid_enabled"] = bool(self.grid_enabled_var.get())
        except Exception: pass

        # Logo (path kept in bindings for compatibility; on/off + formatting here)
        b = self.profile.setdefault("bindings", {})
        try:
            if hasattr(self, "tpl_logo_path_var") and self.tpl_logo_path_var.get() is not None:
                b["logo_path"] = self.tpl_logo_path_var.get().strip()
        except Exception:
            pass
        try: self.profile["logo_enabled"] = bool(self.logo_enabled_var.get())
        except Exception: pass
        try: self.profile["logo_y_pct"] = float(self.logo_y_pct_var.get())
        except Exception: pass
        try: self.profile["logo_w_pct"] = float(self.logo_w_pct_var.get())
        except Exception: pass
        try: self.profile["logo_align"] = (self.logo_align_var.get() or "left").strip()
        except Exception: pass

        # Template free text (if present)
        try:
            if hasattr(self, "template_text") and self.template_text is not None:
                tpl["template_text"] = self.template_text.get("1.0", "end").rstrip("\n")
        except Exception:
            pass

        # Output
        try: self.profile["output_target"] = self.target_var.get()
        except Exception: pass
        try: self.profile["filename_pattern"] = self.fnp_var.get().strip() or "{serial}_{profile}.pdf"
        except Exception: pass
        try: self.profile["copies"] = int(self.copies_var.get())
        except Exception: pass
        try: self.profile["open_after"] = bool(self.open_after_var.get())
        except Exception: pass

        # Data-source metadata
        ds = self.profile.setdefault("data_source", {})
        try:
            if getattr(self, "xlsx_var", None) and self.xlsx_var.get():
                ds["xlsx_path"] = self.xlsx_var.get()
            if getattr(self, "sheet_var", None) and self.sheet_var.get():
                ds["sheet"] = self.sheet_var.get()
            if getattr(self, "serial_col_var", None) and self.serial_col_var.get():
                ds["serial_col"] = self.serial_col_var.get()
        except Exception:
            pass

        try:
            save_profile(self.profile)
        except Exception:
            pass



    def _browse_logo(self):
        try:
            path = filedialog.askopenfilename(
                title="Select Logo image",
                filetypes=[("Images", "*.png *.jpg *.jpeg *.bmp *.gif"), ("All files", "*.*")]
            )
            if not path:
                return
            if not getattr(self, "bv_logo_var", None):
                self.bv_logo_var = tk.StringVar()
            self.bv_logo_var.set(path)
            self._on_profile_field_change()
            self._set_status(f"Logo selected: {path}")
        except Exception as e:
            try:
                messagebox.showerror("Error", f"Failed to select logo: {e}")
            except Exception:
                pass

    def _get_font_families(self):
        """Return a sorted list of installed font family names for dropdowns."""
        try:
            import tkinter.font as tkfont
            fams = sorted(set(tkfont.families()))
            self._font_families = fams
            return fams
        except Exception:
            fams = ["Helvetica", "Times New Roman", "Courier New", "Arial"]
            self._font_families = fams
            return fams

    def _choose_color(self, target_var: tk.StringVar):
        try:
            from tkinter import colorchooser
            initial = (target_var.get() or "").strip() or "#000000"
            _rgb, hx = colorchooser.askcolor(title="Pick a color", initialcolor=initial)
            if hx:
                target_var.set(hx)
                try: self._schedule_autosave()
                except Exception: pass
        except Exception:
            pass

    def _browse_logo_template(self):
        """Browse for a template logo image path."""
        try:
            path = filedialog.askopenfilename(
                title="Select Logo image",
                filetypes=[("Images", "*.png *.jpg *.jpeg *.bmp *.gif"), ("All files", "*.*")]
            )
            if not path:
                return
            if not getattr(self, "tpl_logo_path_var", None):
                self.tpl_logo_path_var = tk.StringVar()
            self.tpl_logo_path_var.set(path)
            try:
                if hasattr(self, "tpl_logo_enabled_var"):
                    self.tpl_logo_enabled_var.set(True)
            except Exception:
                pass
            try:
                self._on_profile_field_change()
                self._set_status(f"Template logo: {path}")
            except Exception:
                pass
        except Exception as e:
            try:
                messagebox.showerror("Logo", f"Failed to select logo: {e}")
            except Exception:
                pass  

    def _sync_profile_to_ui(self):
        if getattr(self, "profile_name_var", None):
            self.profile_name_var.set(self.profile.get("profile_name", self.profile_name_var.get()))

        # Data source
        ds = self.profile.get("data_source", {}) or {}
        if getattr(self, "xlsx_var", None):
            if ds.get("xlsx_path"):
                try:
                    self.xlsx_var.set(ds.get("xlsx_path")); self.xlsx_path = ds.get("xlsx_path")
                except Exception: pass
            if getattr(self, "sheet_menu", None):
                try:
                    sheets = read_excel_sheet_names(ds.get("xlsx_path")) if ds.get("xlsx_path") else []
                    self.sheet_menu["values"] = sheets
                    if ds.get("sheet") and ds.get("sheet") in sheets:
                        self.sheet_var.set(ds.get("sheet"))
                        try: self._load_sheet()
                        except Exception: pass
                except Exception: pass
            if getattr(self, "serial_col_var", None):
                try: self.serial_col_var.set(ds.get("serial_col", self.serial_col_var.get()))
                except Exception: pass
            try:
                if hasattr(self, "profile_serial_pick_var", None) and ds.get("last_serial"):
                    self.profile_serial_pick_var.set(ds.get("last_serial"))
            except Exception:
                pass

        # Template & Layout
        tpl = self.profile.get("template", {}) or {}

        # Mode & Size
        try: self.include_graph_var.set(bool(tpl.get("include_graph", False)))
        except Exception: pass
        try: self.win_var.set(str(self.profile.get("label_w_in", 3.0)))
        except Exception: pass
        try: self.hin_var.set(str(self.profile.get("label_h_in", 4.0)))
        except Exception: pass
        try: self.margin_var.set(int(self.profile.get("margin_pct", DEFAULT_MARGIN_PCT)))
        except Exception: pass
        try: self.text_scale_var.set(int(self.profile.get("text_scale_pct", DEFAULT_TEXT_SCALE_PCT)))
        except Exception: pass
        try: self.plotw_var.set(int(self.profile.get("plot_width_pct", DEFAULT_PLOT_WIDTH_PCT)))
        except Exception: pass
        try: self.graph_margin_var.set(int(self.profile.get("graph_margin_pct", self.profile.get("margin_pct", DEFAULT_MARGIN_PCT))))
        except Exception: pass

        # Title
        try: self.title_color_var.set(self.profile.get("title_color", DEFAULT_TITLE_COLOR))
        except Exception: pass
        try: self.title_size_var.set(int(self.profile.get("title_font_size", 16)))
        except Exception: pass
        try: self.title_y_pct_var.set(float(self.profile.get("title_y_pct", 96.0)))
        except Exception: pass

        # Subtitle
        try: self.subtitle_color_var.set(self.profile.get("subtitle_color", "#333333"))
        except Exception: pass
        try: self.subtitle_size_var.set(int(self.profile.get("subtitle_font_size", 12)))
        except Exception: pass
        try: self.subtitle_y_pct_var.set(float(self.profile.get("subtitle_y_pct", 86.0)))
        except Exception: pass

        # Labels / Values
        try: self.labels_color_var.set(self.profile.get("labels_color", "#333333"))
        except Exception: pass
        try: self.labels_size_var.set(int(self.profile.get("labels_font_size", 11)))
        except Exception: pass
        try: self.rows_top_y_pct_var.set(float(self.profile.get("rows_top_y_pct", 78.0)))
        except Exception: pass
        try: self.line_height_pct_var.set(float(self.profile.get("line_height_pct", 7.5)))
        except Exception: pass
        try: self.label_value_gap_pct_var.set(float(self.profile.get("label_value_gap_pct", 10.0)))
        except Exception: pass
        try: self.values_color_var.set(self.profile.get("values_color", "#000000"))
        except Exception: pass
        try: self.values_size_var.set(int(self.profile.get("values_font_size", 11)))
        except Exception: pass

        # Graph axis & line
        try: self.axis_label_size_var.set(int(self.profile.get("axis_label_font_size", 8)))
        except Exception: pass
        try: self.axis_tick_size_var.set(int(self.profile.get("axis_tick_font_size", 6)))
        except Exception: pass
        try: self.axis_color_var.set(self.profile.get("axis_color", "#666666"))
        except Exception: pass
        try: self.graph_line_color_var.set(self.profile.get("graph_line_color", "#1F77B4"))
        except Exception: pass
        try: self.grid_enabled_var.set(bool(self.profile.get("grid_enabled", True)))
        except Exception: pass

        # Logo
        try:
            # path from bindings for compatibility
            self.tpl_logo_path_var.set(self.profile.get("bindings", {}).get("logo_path", ""))
        except Exception: pass
        try: self.logo_enabled_var.set(bool(self.profile.get("logo_enabled", False)))
        except Exception: pass
        try: self.logo_y_pct_var.set(float(self.profile.get("logo_y_pct", 70.0)))
        except Exception: pass
        try: self.logo_w_pct_var.set(float(self.profile.get("logo_w_pct", 28.0)))
        except Exception: pass
        try: self.logo_align_var.set(self.profile.get("logo_align", "left"))
        except Exception: pass

        # Template text (if present)
        if getattr(self, "template_text", None):
            try:
                self.template_text.delete("1.0", "end")
                self.template_text.insert("1.0", tpl.get("template_text", ""))
            except Exception:
                pass

        # Output
        try: self.target_var.set(self.profile.get("output_target", TARGET_LX900_3x4))
        except Exception: pass
        try: self.fnp_var.set(self.profile.get("filename_pattern", "{serial}_{profile}.pdf"))
        except Exception: pass
        try: self.copies_var.set(int(self.profile.get("copies", 1)))
        except Exception: pass
        try: self.open_after_var.set(bool(self.profile.get("open_after", True)))
        except Exception: pass
        try:
            if not self.outdir_var.get():
                self.outdir_var.set(str(Path.cwd()))
        except Exception:
            pass

        # Bindings panels and controls
        try: self._refresh_binding_columns()
        except Exception: pass
        try: self._toggle_binding_panels()
        except Exception: pass
        try: self._update_graph_controls_visibility()
        except Exception: pass

        try: self._update_profile_header()
        except Exception:
            pass

    def _sync_ui_to_profile(self):
        self._on_profile_field_change()

    def _update_graph_controls_visibility(self):
        try:
            graph_mode = bool(self.include_graph_var.get())
        except Exception:
            graph_mode = False

        try:
            self.plotw_spin.configure(state="normal" if graph_mode else "disabled")
        except Exception:
            pass
        try:
            if hasattr(self, "list_cols") and self.list_cols is not None:
                self.list_cols.configure(state="normal" if graph_mode else "disabled")
        except Exception:
            pass
        for cb in getattr(self, "g_slot_col_cbs", []):
            try: cb.configure(state="readonly" if graph_mode else "disabled")
            except Exception: pass
        for cb in getattr(self, "slot_col_cbs", []):
            try: cb.configure(state="readonly" if not graph_mode else "disabled")
            except Exception: pass

    # ========== Actions & rendering ==========
    def _get_selected_row(self) -> Optional[pd.Series]:
        if self.df is None or self.current_row_index is None:
            return None
        try:
            return self.df.loc[self.current_row_index]
        except Exception:
            return None

    def _get_output_dir(self) -> Path:
        try:
            val = self.outdir_var.get().strip() if hasattr(self, "outdir_var") and self.outdir_var is not None else ""
            return Path(val) if val else Path.cwd()
        except Exception:
            return Path.cwd()

    def on_preview(self):
        row = self._get_selected_row()
        if row is None:
            messagebox.showerror("Preview", "Select a data row first.")
            return
        try: self._sync_ui_to_profile()
        except Exception: pass

        out_dir = self._get_output_dir()
        out_dir.mkdir(parents=True, exist_ok=True)
        tmp_pdf = out_dir / "_preview_label.pdf"

        try:
            render_profile_to_pdf(self.profile, self.df, row, tmp_pdf)
            if not tmp_pdf.exists() or tmp_pdf.stat().st_size == 0:
                messagebox.showerror("Preview failed", f"Output file missing or empty: {tmp_pdf}")
                self._set_status("Preview failed: output missing")
                return
            self.last_pdf = tmp_pdf
            try: self._open_file(tmp_pdf)
            except Exception: pass
            self._set_status(f"Preview generated: {tmp_pdf}")
        except Exception as e:
            import traceback
            tb = traceback.format_exc()
            try: messagebox.showerror("Preview failed", f"{e}\n\n{tb}")
            except Exception:
                print("Preview failed:", e); print(tb)
            self._set_status("Preview failed: see console")

    def on_generate(self):
        row = self._get_selected_row()
        if row is None:
            messagebox.showerror("Generate", "Select a data row first.")
            return
        try: self._sync_ui_to_profile()
        except Exception: pass

        serial_col = self.serial_col_var.get() if hasattr(self, "serial_col_var") else ""
        serial_val = str(row.get(serial_col, "")).strip() if serial_col else ""
        filename = self.profile.get("filename_pattern", "{serial}_{profile}.pdf")
        filename = filename.replace("{serial}", serial_val or "row")
        filename = filename.replace("{profile}", self.profile.get("profile_name", "Profile"))

        out_dir = self._get_output_dir()
        out_dir.mkdir(parents=True, exist_ok=True)
        out_pdf = out_dir / filename

        try:
            render_profile_to_pdf(self.profile, self.df, row, out_pdf)
            if not out_pdf.exists() or out_pdf.stat().st_size == 0:
                messagebox.showerror("Generate failed", f"Output file missing or empty: {out_pdf}")
                self._set_status("Generate failed: output missing")
                return
            self.last_pdf = out_pdf
            open_after = False
            try: open_after = bool(self.open_after_var.get())
            except Exception: pass
            if open_after:
                try: self._open_file(out_pdf)
                except Exception: pass
            self._set_status(f"PDF generated: {out_pdf}")
        except Exception as e:
            import traceback
            tb = traceback.format_exc()
            try: messagebox.showerror("Generate failed", f"{e}\n\n{tb}")
            except Exception:
                print("Generate failed:", e); print(tb)
            self._set_status("Generate failed: see console")

    def _open_file(self, path: Path):
        try:
            if sys.platform.startswith("win"):
                os.startfile(str(path))  # type: ignore[attr-defined>
            elif sys.platform == "darwin":
                os.system(f"open '{path}'")
            else:
                os.system(f"xdg-open '{path}'")
        except Exception:
            pass

    # ========== Utilities: profile lifecycle ==========
    def _refresh_profile_list(self):
        names = list_profiles()
        self.profile_pick_menu["values"] = names
        if self.profile.get("profile_name") and self.profile.get("profile_name") in names:
            self.profile_pick_var.set(self.profile.get("profile_name"))

    def _load_selected_profile(self):
        name = self.profile_pick_var.get().strip()
        if not name:
            return
        try:
            self.profile = load_profile(name)
            if "template" not in self.profile:
                self.profile["template"] = {}
            self.profile_name_var.set(self.profile.get("profile_name", name))

            # Sync all UI from profile (this loads sheet if present)
            self._sync_profile_to_ui()

            # Make sure Bindings tab widgets are correctly enabled/disabled and populated
            self._ensure_graph_ui_ready()

            # Update header text
            try:
                self._update_profile_header()
            except Exception:
                pass

            self._set_status(f"Profile loaded: {name}")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to load profile: {e}")

    def _new_profile(self):
        """
        Create a fresh profile using the default template settings.
        Keeps current Data Source selections (xlsx/sheet/serial) so you don't have to re-pick.
        Ensures graph bindings are enabled and selectable immediately.
        """
        try:
            # Start with a fresh profile model
            new_prof = default_profile(TEMPLATE_GRAPH)

            # Optionally carry over current output settings and filename pattern
            try:
                new_prof["output_target"] = self.profile.get("output_target", new_prof.get("output_target"))
                new_prof["filename_pattern"] = self.profile.get("filename_pattern", new_prof.get("filename_pattern", "{serial}_{profile}.pdf"))
                new_prof["copies"] = self.profile.get("copies", new_prof.get("copies", 1))
                new_prof["open_after"] = self.profile.get("open_after", new_prof.get("open_after", True))
            except Exception:
                pass

            # Keep current Data Source selection (if present) to avoid re-picking
            ds = {}
            try:
                if hasattr(self, "xlsx_var") and self.xlsx_var.get():
                    ds["xlsx_path"] = self.xlsx_var.get()
                if hasattr(self, "sheet_var") and self.sheet_var.get():
                    ds["sheet"] = self.sheet_var.get()
                if hasattr(self, "serial_col_var") and self.serial_col_var.get():
                    ds["serial_col"] = self.serial_col_var.get()
                if hasattr(self, "serial_pick_var") and self.serial_pick_var.get():
                    ds["last_serial"] = self.serial_pick_var.get()
            except Exception:
                pass
            if ds:
                new_prof["data_source"] = ds

            # Swap in and refresh UI
            self.profile = new_prof
            try:
                self.profile_name_var.set(self.profile.get("profile_name", "Profile"))
            except Exception:
                pass

            # Force Include Graph ON for new graph profile so widgets aren't greyed out
            try:
                self.include_graph_var.set(True)
                self.profile.setdefault("template", {})["include_graph"] = True
            except Exception:
                pass

            # Re-apply to UI and make graph UI ready
            self._sync_profile_to_ui()
            self._ensure_graph_ui_ready()

            # Don’t save automatically; user can Save or Save As to name it
            self._set_status(f"New profile created: {self.profile.get('profile_name', 'Profile')}")
        except Exception as e:
            messagebox.showerror("New Profile", f"Failed to create new profile: {e}")

    def on_save_profile(self):
        self._sync_ui_to_profile()
        p = save_profile(self.profile)
        self._refresh_profile_list()
        self._set_status(f"Profile saved: {p}")

    def on_save_as_profile(self):
        self._sync_ui_to_profile()
        name = self._prompt_text("Save Profile As", "Profile name:", default=self.profile.get("profile_name", "Profile"))
        if not name:
            return
        self.profile["profile_name"] = name
        p = save_profile(self.profile)
        self._refresh_profile_list()
        self.profile_pick_var.set(self.profile["profile_name"])
        self._set_status(f"Profile saved as: {p}")

    def on_delete_profile(self):
        name = self.profile_pick_var.get().strip()
        if not name:
            messagebox.showinfo("Delete", "Select a profile to delete.")
            return
        if not messagebox.askyesno("Delete", f"Delete profile '{name}'?"):
            return
        try:
            pp = PROFILE_DIR / f"{name}.json"
            if pp.exists():
                pp.unlink()
            self._refresh_profile_list()
            self._set_status(f"Deleted profile: {name}")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to delete: {e}")

    def _browse_outdir(self):
        path = filedialog.askdirectory(title="Select output folder")
        if path:
            self.outdir_var.set(path)
            self._schedule_autosave()

    def _flash_message(self, msg: str, ms: int = 1200):
        try:
            self._set_status(msg)
            if getattr(self, "_flash_after_id", None):
                try: self.after_cancel(self._flash_after_id)
                except Exception: pass
            def _clear():
                try: self._set_status("")
                except Exception: pass
            self._flash_after_id = self.after(ms, _clear)
        except Exception:
            pass

    def _prompt_text(self, title: str, prompt: str, default: str = "") -> Optional[str]:
        win = tk.Toplevel(self); win.title(title)
        ttk.Label(win, text=prompt).pack(side="top", anchor="w", padx=10, pady=(10, 4))
        var = tk.StringVar(value=default)
        ent = ttk.Entry(win, textvariable=var, width=40); ent.pack(side="top", padx=10, pady=(0, 10))
        out = {"ok": False}
        def ok(): out["ok"] = True; win.destroy()
        def cancel(): win.destroy()
        btns = ttk.Frame(win); btns.pack(side="top", padx=10, pady=(0, 10))
        ttk.Button(btns, text="OK", command=ok).pack(side="left", padx=(0, 8))
        ttk.Button(btns, text="Cancel", command=cancel).pack(side="left")
        ent.focus_set(); win.grab_set(); self.wait_window(win)
        return var.get().strip() if out["ok"] else None

    def _set_status(self, msg: str):
        self.status_var.set(msg)
        self.update_idletasks()

    def on_close(self):
        try:
            self._sync_ui_to_profile()
            save_profile(self.profile)
        except Exception:
            pass
        self.master.destroy()

def main():
    root = tk.Tk()
    try:
        if sys.platform.startswith("win"):
            root.tk.call('tk', 'scaling', 1.25)
    except Exception:
        pass
    app = App(root)
    root.minsize(980, 720)
    root.mainloop()

if __name__ == "__main__":
    main()
