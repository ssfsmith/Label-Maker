"""
Label Maker (Profiles) - single-file app

- Profile tab: Template & Layout + Output (persisted in profile)
- Bindings tab: Graph bindings and Value bindings (scrollable, persisted)
- Actions tab: Preview & Generate
- Data Source tab (last): Excel path, sheet, serial selection + Save button

Bindings persistence:
- Flow columns (X) listbox: saved on selection
- Graph Value slots: label entries saved on focus-out; column comboboxes saved on selection
- Non-graph Value bindings: same behavior
- Explicit "Save Bindings" button writes to disk and flashes confirmation

Output persistence:
- Output target, filename pattern, copies, open-after, output folder
"""

import os, sys
HERE = os.path.dirname(os.path.abspath(__file__))
if HERE not in sys.path:
    sys.path.insert(0, HERE)

from pathlib import Path
from typing import List, Dict, Optional

import tkinter as tk
from tkinter import ttk, filedialog, messagebox

import pandas as pd

from render import (
    PROFILE_DIR,
    TEMPLATE_GRAPH, TEMPLATE_VALUE_A, TEMPLATE_VALUE_B, TEMPLATE_VALUE_C,
    TARGET_LETTER_TWO_UP, TARGET_LX900_3x4,
    DEFAULT_TITLE_COLOR, DEFAULT_TEXT_SCALE_PCT, DEFAULT_MARGIN_PCT, DEFAULT_PLOT_WIDTH_PCT,
    read_excel_sheet_names, read_excel_sheet, list_profiles, default_profile, save_profile, load_profile,
    render_profile_to_pdf,
)

APP_TITLE = "Label Maker (Profiles)"

class ScrollableFrame(ttk.Frame):
    """Scrollable area that auto-disables scrolling when not needed."""
    def __init__(self, container, *args, **kwargs):
        super().__init__(container, *args, **kwargs)

        # Match TTK frame background so it doesn't look like a gray box
        try:
            style = ttk.Style()
            bg = style.lookup("TFrame", "background") or self.cget("background")
        except Exception:
            bg = self.cget("background")

        self.canvas = tk.Canvas(self, borderwidth=0, highlightthickness=0, bg=bg)
        self.vscroll = ttk.Scrollbar(self, orient="vertical", command=self.canvas.yview)
        self.scrollable_frame = ttk.Frame(self.canvas)

        # Place inner frame and keep a reference to the window id
        self._window_id = self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")

        # When inner content changes size -> update scrollregion and scrollbar visibility
        self.scrollable_frame.bind("<Configure>", lambda e: self._on_frame_configure())
        # When canvas changes size -> stretch inner frame to canvas width and reevaluate
        self.canvas.bind("<Configure>", lambda e: self._on_canvas_configure())

        self.canvas.pack(side="left", fill="both", expand=True)
        self.vscroll.pack(side="right", fill="y")

        # Mouse wheel binding is toggled depending on need
        self._wheel_bound = False

    def _on_frame_configure(self):
        try:
            self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        except Exception:
            pass
        self._update_scrollbar_visibility()

    def _on_canvas_configure(self):
        # Stretch inner frame to the canvas width to avoid narrow “box”
        try:
            self.canvas.itemconfigure(self._window_id, width=self.canvas.winfo_width())
        except Exception:
            pass
        self._update_scrollbar_visibility()

    def _update_scrollbar_visibility(self):
        # Show scrollbar and enable wheel only if content is taller than viewport
        try:
            need = self.scrollable_frame.winfo_reqheight() > self.canvas.winfo_height()
        except Exception:
            need = False

        if need:
            # ensure connections and show bar
            self.canvas.configure(yscrollcommand=self.vscroll.set)
            if not self.vscroll.winfo_ismapped():
                self.vscroll.pack(side="right", fill="y")
            self._bind_wheel()
        else:
            # lock at top and hide bar
            try:
                self.canvas.yview_moveto(0)
            except Exception:
                pass
            if self.vscroll.winfo_ismapped():
                self.vscroll.pack_forget()
            self.canvas.configure(yscrollcommand=None)
            self._unbind_wheel()

    def _bind_wheel(self):
        if self._wheel_bound:
            return
        for w in (self.canvas, self.scrollable_frame):
            # Windows/macOS
            w.bind("<MouseWheel>", self._on_mousewheel)
            # Linux
            w.bind("<Button-4>", self._on_mousewheel)
            w.bind("<Button-5>", self._on_mousewheel)
        self._wheel_bound = True

    def _unbind_wheel(self):
        if not self._wheel_bound:
            return
        for w in (self.canvas, self.scrollable_frame):
            w.unbind("<MouseWheel>")
            w.unbind("<Button-4>")
            w.unbind("<Button-5>")
        self._wheel_bound = False

    def _on_mousewheel(self, event):
        try:
            # Linux (button-based)
            if getattr(event, "num", None) == 4:
                self.canvas.yview_scroll(-1, "units"); return
            if getattr(event, "num", None) == 5:
                self.canvas.yview_scroll(1, "units"); return
            # Windows/macOS (delta-based)
            if event.delta < 0:
                self.canvas.yview_scroll(1, "units")
            elif event.delta > 0:
                self.canvas.yview_scroll(-1, "units")
        except Exception:
            pass

class App(ttk.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.master.title(APP_TITLE)
        self.pack(fill="both", expand=True)

        # State
        self.df: Optional[pd.DataFrame] = None
        self.xlsx_path: Optional[str] = None
        self.current_row_index: Optional[int] = None
        self.profile: Dict = default_profile(TEMPLATE_GRAPH)
        self.last_pdf: Optional[Path] = None

        # Vars that are referenced in multiple tabs — define early
        self.outdir_var = tk.StringVar(value=str(Path.cwd()))

        # Keep references to comboboxes
        self.slot_col_cbs: List[ttk.Combobox] = []
        self.g_slot_col_cbs: List[ttk.Combobox] = []

        # Autosave debounce
        self._autosave_after_id = None

        # Style
        self._init_style()

        # Notebook
        self.nb = ttk.Notebook(self)
        self.nb.pack(fill="both", expand=True, padx=8, pady=6)

        # Build tabs: Profile, Bindings, Actions, Data Source (last)
        self._build_tab_profiles()
        self._build_tab_bindings()
        self._build_tab_actions()
        self._build_tab_data()

        # Status
        self.status_var = tk.StringVar(value="")
        status = ttk.Label(self, textvariable=self.status_var, relief="sunken", anchor="w")
        status.pack(fill="x", padx=0, pady=(2, 0), ipady=2)

        # Profiles list
        self._refresh_profile_list()

        # Auto-load a profile at startup, if one exists
        try:
            names = list_profiles()
            pref = self.profile.get("profile_name")
            if pref and pref in names:
                self.profile_pick_var.set(pref)
                self._load_selected_profile()
            elif names:
                self.profile_pick_var.set(names[0])
                self._load_selected_profile()
        except Exception:
            pass

        self.master.protocol("WM_DELETE_WINDOW", self.on_close)


    def _init_style(self):
        style = ttk.Style()
        try:
            style.theme_use("clam")
        except Exception:
            pass
        style.configure("TLabel", padding=2)
        style.configure("TButton", padding=4)
        style.configure("TLabelframe", padding=6)
        style.configure("TLabelframe.Label", font=("Segoe UI", 10, "bold"))
        # Header label style: bigger, bold
        try:
            style.configure("ProfileHeader.TLabel", font=("Segoe UI", 14, "bold"))
        except Exception:
            pass


    def _make_profile_header(self, parent) -> ttk.Label:
        """
        Create a bold, large header showing the current profile name on a given tab.
        The label is registered so future name changes update everywhere.
        """
        if not hasattr(self, "_profile_header_labels"):
            self._profile_header_labels = []
        text = f"Profile: {self.profile.get('profile_name', 'Profile')}"
        lbl = ttk.Label(parent, text=text, style="ProfileHeader.TLabel")
        lbl.pack(fill="x", padx=10, pady=(8, 4))
        self._profile_header_labels.append(lbl)
        return lbl

    def _update_profile_header(self):
        """
        Update all header labels to reflect the current profile name.
        Safe if called before labels exist.
        """
        try:
            name = ""
            if hasattr(self, "profile_name_var") and self.profile_name_var is not None:
                name = (self.profile_name_var.get() or "").strip()
            if not name:
                name = self.profile.get("profile_name", "Profile")
            text = f"Profile: {name}"
            for lbl in getattr(self, "_profile_header_labels", []):
                try:
                    lbl.config(text=text)
                except Exception:
                    pass
        except Exception:
            pass

    # ========== Data Source (last tab) ==========
    def _build_tab_data(self):
        tab = ttk.Frame(self.nb)
        self.nb.add(tab, text="Data Source")

        # Header (fixed)
        self._make_profile_header(tab)

        f = ttk.Frame(tab)
        f.pack(fill="x", padx=10, pady=10)

        ttk.Label(f, text="Excel file:").grid(row=0, column=0, sticky="w")
        self.xlsx_var = tk.StringVar(value=self.profile.get("data_source", {}).get("xlsx_path", ""))
        ttk.Entry(f, textvariable=self.xlsx_var, width=60).grid(row=0, column=1, sticky="we", padx=(6, 6))
        ttk.Button(f, text="Browse...", command=self.on_browse_excel).grid(row=0, column=2, sticky="w")

        ttk.Label(f, text="Sheet:").grid(row=1, column=0, sticky="w", pady=(8, 0))
        self.sheet_var = tk.StringVar(value=self.profile.get("data_source", {}).get("sheet", ""))
        self.sheet_menu = ttk.Combobox(f, textvariable=self.sheet_var, width=28, state="readonly")
        self.sheet_menu.grid(row=1, column=1, sticky="w", padx=(6, 6), pady=(8, 0))
        self.sheet_menu.bind("<<ComboboxSelected>>", lambda e: self._load_sheet())

        ttk.Label(f, text="Serial column:").grid(row=2, column=0, sticky="w", pady=(8, 0))
        self.serial_col_var = tk.StringVar(value=self.profile.get("data_source", {}).get("serial_col", ""))
        self.serial_col_menu = ttk.Combobox(f, textvariable=self.serial_col_var, width=28, state="readonly")
        self.serial_col_menu.grid(row=2, column=1, sticky="w", padx=(6, 6), pady=(8, 0))
        self.serial_col_menu.bind("<<ComboboxSelected>>", lambda e: self._refresh_serials())

        ttk.Label(f, text="Serial (row):").grid(row=3, column=0, sticky="w", pady=(8, 0))
        # Allow typing to jump/select by serial quickly
        self.serial_pick_var = tk.StringVar()
        self.serial_pick_menu = ttk.Combobox(f, textvariable=self.serial_pick_var, width=40, state="normal")
        self.serial_pick_menu.grid(row=3, column=1, sticky="w", padx=(6, 6), pady=(8, 0))
        self.serial_pick_menu.bind("<<ComboboxSelected>>", lambda e: self._select_row_by_serial())
        # Type-to-select handlers
        self.serial_pick_menu.bind("<KeyRelease>", self._on_serial_typed_data)
        self.serial_pick_menu.bind("<Return>", self._on_serial_typed_data)

        ttk.Button(f, text="Save Data Source", command=self.on_save_data_source).grid(row=4, column=1, sticky="e", pady=(8, 0))

        f.columnconfigure(1, weight=1)

    def on_save_data_source(self):
        try:
            self.profile.setdefault("data_source", {})
            if self.xlsx_var.get():
                self.profile["data_source"]["xlsx_path"] = self.xlsx_var.get()
            if self.sheet_var.get():
                self.profile["data_source"]["sheet"] = self.sheet_var.get()
            if self.serial_col_var.get():
                self.profile["data_source"]["serial_col"] = self.serial_col_var.get()
            if self.serial_pick_var.get():
                self.profile["data_source"]["last_serial"] = self.serial_pick_var.get()
            save_profile(self.profile)
            self._flash_message("Data source saved", 1200)
        except Exception as e:
            messagebox.showerror("Save Data Source", f"Failed to save data source: {e}")

    def on_browse_excel(self):
        path = filedialog.askopenfilename(
            title="Select Excel file",
            filetypes=[("Excel files", "*.xlsx *.xlsm *.xls"), ("All files", "*.*")]
        )
        if not path:
            return
        self.xlsx_path = path
        self.xlsx_var.set(path)
        self.profile.setdefault("data_source", {})
        self.profile["data_source"]["xlsx_path"] = path
        try:
            sheets = read_excel_sheet_names(path)
            self.sheet_menu["values"] = sheets
            if sheets:
                saved_sheet = self.profile.get("data_source", {}).get("sheet")
                self.sheet_var.set(saved_sheet if (saved_sheet in sheets) else sheets[0])
                self._load_sheet()
            self._set_status(f"Loaded: {path}")
            save_profile(self.profile)
        except Exception as e:
            messagebox.showerror("Error", f"Error reading Excel: {e}")
            self._set_status(f"Error reading Excel: {e}")

    def _load_sheet(self):
        if not (self.xlsx_var.get() or self.xlsx_path) or not self.sheet_var.get():
            return
        path = self.xlsx_var.get() or self.xlsx_path
        try:
            self.df = read_excel_sheet(path, self.sheet_var.get())
            self.profile.setdefault("data_source", {})
            self.profile["data_source"]["xlsx_path"] = path
            self.profile["data_source"]["sheet"] = self.sheet_var.get()

            cols = list(self.df.columns)
            self.serial_col_menu["values"] = cols
            guess = next((c for c in cols if "serial" in str(c).lower()), cols[0] if cols else "")
            saved_serial_col = self.profile.get("data_source", {}).get("serial_col")
            self.serial_col_var.set(saved_serial_col if saved_serial_col in cols else guess)

            # Populate serials and bindings, then make graph UI ready
            self._refresh_serials()
            self._ensure_graph_ui_ready()

            self._set_status(f"Loaded sheet: {self.sheet_var.get()} ({len(self.df)} rows, {len(self.df.columns)} cols)")
            save_profile(self.profile)
        except Exception as e:
            self.df = None
            messagebox.showerror("Error", f"Error loading sheet: {e}")
            self._set_status(f"Error loading sheet: {e}")

    def _render_selected_cols_view(self):
        """
        Render selected Flow columns (X) top-to-bottom into the read-only text panel
        to the right of the listbox.
        """
        try:
            if not hasattr(self, "selected_cols_text") or not hasattr(self, "list_cols"):
                return
            sel_names = []
            try:
                sel_indices = list(self.list_cols.curselection())
                for i in sel_indices:
                    sel_names.append(self.list_cols.get(i))
            except Exception:
                sel_names = []

            # Update text content
            self.selected_cols_text.configure(state="normal")
            self.selected_cols_text.delete("1.0", "end")
            if sel_names:
                self.selected_cols_text.insert("1.0", "\n".join(sel_names))
            else:
                self.selected_cols_text.insert("1.0", "(none)")
            self.selected_cols_text.configure(state="disabled")
        except Exception:
            pass


    def _refresh_serials(self):
        if self.df is None or not self.serial_col_var.get():
            self.serial_pick_menu["values"] = []
            # also clear profile tab serial values
            try:
                self._update_profile_serial_menu_values([])
            except Exception:
                pass
            return
        col = self.serial_col_var.get()
        try:
            serials = [str(s).strip() for s in self.df[col].astype(str).fillna("").tolist()]
            seen, dedup = set(), []
            for s in serials:
                if s not in seen:
                    seen.add(s)
                    dedup.append(s)
            self.serial_pick_menu["values"] = dedup
            # keep Profile tab serial combo in sync
            try:
                self._update_profile_serial_menu_values(dedup)
            except Exception:
                pass
            if dedup:
                # prefer persisted last_serial if available; else last value
                last = (self.profile.get("data_source", {}) or {}).get("last_serial")
                pick = last if (last in dedup) else dedup[-1]
                self.serial_pick_var.set(pick)
                self.profile.setdefault("data_source", {})["last_serial"] = pick
                try:
                    save_profile(self.profile)
                except Exception:
                    pass
                self._select_row_by_serial()
        except Exception:
            pass

    def _select_row_by_serial(self):
        if self.df is None or not self.serial_col_var.get() or not self.serial_pick_var.get():
            return
        serial = self.serial_pick_var.get().strip()
        col = self.serial_col_var.get()
        dff = self.df[self.df[col].astype(str).str.strip() == serial]
        if len(dff) == 0:
            self.current_row_index = None
            self._set_status("Serial not found in current sheet.")
            return
        self.current_row_index = dff.index[-1]
        self.profile.setdefault("data_source", {})["serial_col"] = col
        save_profile(self.profile)
        self._set_status(f"Selected row index: {self.current_row_index}")

    # ========== Profile tab ==========
    def _build_tab_profiles(self):
        tab = ttk.Frame(self.nb)
        self.nb.add(tab, text="Profile")

        # Header (fixed, non-scrolling)
        self._make_profile_header(tab)

        f = ttk.Frame(tab); f.pack(fill="x", padx=10, pady=10)

        ttk.Label(f, text="Profile:").grid(row=0, column=0, sticky="w")
        self.profile_pick_var = tk.StringVar()
        self.profile_pick_menu = ttk.Combobox(f, textvariable=self.profile_pick_var, width=40, state="readonly")
        self.profile_pick_menu.grid(row=0, column=1, sticky="we", padx=(6, 6))
        self.profile_pick_menu.bind("<<ComboboxSelected>>", lambda e: self._load_selected_profile())

        ttk.Button(f, text="New", command=self._new_profile).grid(row=0, column=2, padx=(4, 0))

        ttk.Label(f, text="Name:").grid(row=1, column=0, sticky="w", pady=(8, 0))
        self.profile_name_var = tk.StringVar(value=self.profile.get("profile_name"))
        ttk.Entry(f, textvariable=self.profile_name_var, width=40).grid(row=1, column=1, sticky="w", padx=(6, 6), pady=(8, 0))

        ttk.Button(f, text="Save", command=self.on_save_profile).grid(row=1, column=2, pady=(8, 0))
        ttk.Button(f, text="Save As...", command=self.on_save_as_profile).grid(row=1, column=3, pady=(8, 0))
        ttk.Button(f, text="Delete", command=self.on_delete_profile).grid(row=1, column=4, pady=(8, 0))

        # Profile tab Serial (row) picker (mirrors Data Source tab) with typing support
        ttk.Label(f, text="Serial (row):").grid(row=2, column=0, sticky="w", pady=(8, 0))
        self.profile_serial_pick_var = tk.StringVar()
        self.profile_serial_pick_menu = ttk.Combobox(f, textvariable=self.profile_serial_pick_var, width=40, state="normal")
        self.profile_serial_pick_menu.grid(row=2, column=1, sticky="w", padx=(6, 6), pady=(8, 0))
        self.profile_serial_pick_menu.bind("<<ComboboxSelected>>", lambda e: self._on_profile_tab_serial_selected())
        # Type-to-select handlers
        self.profile_serial_pick_menu.bind("<KeyRelease>", self._on_serial_typed_profile)
        self.profile_serial_pick_menu.bind("<Return>", self._on_serial_typed_profile)

        f.columnconfigure(1, weight=1)

        # -- Template & Layout --
        tf = ttk.LabelFrame(tab, text="Template & Layout")
        tf.pack(fill="x", padx=10, pady=(6, 10))

        self.include_graph_var = tk.BooleanVar(value=bool(self.profile.get("template", {}).get("include_graph", False)))
        ttk.Checkbutton(tf, text="Include graph", variable=self.include_graph_var, command=self._ensure_graph_ui_ready).grid(row=0, column=0, sticky="w", padx=4, pady=4)

        ttk.Label(tf, text="Graph scale:").grid(row=0, column=1, sticky="e")
        self.graph_scale_var = tk.DoubleVar(value=float(self.profile.get("template", {}).get("graph_scale", 1.0)))
        ttk.Entry(tf, textvariable=self.graph_scale_var, width=6).grid(row=0, column=2, sticky="w", padx=(6, 12))

        ttk.Label(tf, text="Graph X:").grid(row=0, column=3, sticky="e")
        self.graph_x_var = tk.DoubleVar(value=float(self.profile.get("template", {}).get("graph_x", 0.0)))
        ttk.Entry(tf, textvariable=self.graph_x_var, width=6).grid(row=0, column=4, sticky="w", padx=(6, 12))

        ttk.Label(tf, text="Graph Y:").grid(row=0, column=5, sticky="e")
        self.graph_y_var = tk.DoubleVar(value=float(self.profile.get("template", {}).get("graph_y", 0.0)))
        ttk.Entry(tf, textvariable=self.graph_y_var, width=6).grid(row=0, column=6, sticky="w", padx=(6, 12))

        # Title color + Pick button
        ttk.Label(tf, text="Title color (hex):").grid(row=1, column=0, sticky="w")
        self.title_color_var = tk.StringVar(value=self.profile.get("title_color", DEFAULT_TITLE_COLOR))
        ttk.Entry(tf, textvariable=self.title_color_var, width=12).grid(row=1, column=1, sticky="w", padx=(6, 6))
        ttk.Button(tf, text="Pick...", command=lambda: self._choose_color(self.title_color_var)).grid(row=1, column=6, sticky="w")

        ttk.Label(tf, text="Text scale %:").grid(row=1, column=2, sticky="w", pady=(8, 0))
        self.text_scale_var = tk.IntVar(value=int(self.profile.get("text_scale_pct", DEFAULT_TEXT_SCALE_PCT)))
        ttk.Spinbox(tf, from_=60, to=160, increment=1, textvariable=self.text_scale_var, width=6, justify="right").grid(row=1, column=3, sticky="w", padx=(6, 12), pady=(8, 0))

        ttk.Label(tf, text="Margins %:").grid(row=1, column=4, sticky="w", pady=(8, 0))
        self.margin_var = tk.IntVar(value=int(self.profile.get("margin_pct", DEFAULT_MARGIN_PCT)))
        ttk.Spinbox(tf, from_=3, to=15, increment=1, textvariable=self.margin_var, width=6, justify="right").grid(row=1, column=5, sticky="w", padx=(6, 12), pady=(8, 0))

        ttk.Label(tf, text="Label W (in):").grid(row=2, column=0, sticky="w", pady=(8, 0))
        self.win_var = tk.StringVar(value=str(self.profile.get("label_w_in", 3.0)))
        ttk.Entry(tf, textvariable=self.win_var, width=6).grid(row=2, column=1, sticky="w", padx=(6, 12), pady=(8, 0))
        ttk.Label(tf, text="H:").grid(row=2, column=2, sticky="w", pady=(8, 0))
        self.hin_var = tk.StringVar(value=str(self.profile.get("label_h_in", 4.0)))
        ttk.Entry(tf, textvariable=self.hin_var, width=6).grid(row=2, column=3, sticky="w", padx=(6, 12), pady=(8, 0))

        # Plot width and Graph line color + Pick
        ttk.Label(tf, text="Plot width % (graph):").grid(row=3, column=0, sticky="w", pady=(8, 0))
        self.plotw_var = tk.IntVar(value=int(self.profile.get("plot_width_pct", DEFAULT_PLOT_WIDTH_PCT)))
        self.plotw_spin = ttk.Spinbox(tf, from_=30, to=80, increment=1, textvariable=self.plotw_var, width=6, justify="right")
        self.plotw_spin.grid(row=3, column=1, sticky="w", padx=(6, 12), pady=(8, 0))

        ttk.Label(tf, text="Graph line color:").grid(row=3, column=2, sticky="e")
        self.graph_line_color_var = tk.StringVar(value=self.profile.get("graph_line_color", "#1F77B4"))
        ttk.Entry(tf, textvariable=self.graph_line_color_var, width=12).grid(row=3, column=3, sticky="w", padx=(6, 6))
        ttk.Button(tf, text="Pick...", command=lambda: self._choose_color(self.graph_line_color_var)).grid(row=3, column=4, sticky="w")

        ttk.Label(tf, text="Template text:").grid(row=4, column=0, sticky="nw", padx=4, pady=(8,3))
        self.template_text = tk.Text(tf, width=76, height=6)
        self.template_text.grid(row=4, column=1, columnspan=6, padx=4, pady=(8,3))
        self.template_text.insert("1.0", self.profile.get("template", {}).get("template_text", ""))

        # Output (inside Profile tab)
        of = ttk.LabelFrame(tab, text="Output")
        of.pack(fill="x", padx=10, pady=(6, 10))

        ttk.Label(of, text="Output target:").grid(row=0, column=0, sticky="w")
        self.target_var = tk.StringVar(value=self.profile.get("output_target", TARGET_LX900_3x4))
        target_menu = ttk.Combobox(of, textvariable=self.target_var,
                                values=[TARGET_LETTER_TWO_UP, TARGET_LX900_3x4],
                                width=24, state="readonly")
        target_menu.grid(row=0, column=1, sticky="w", padx=(6, 12))

        ttk.Label(of, text="Filename pattern:").grid(row=1, column=0, sticky="w", pady=(8, 0))
        self.fnp_var = tk.StringVar(value=self.profile.get("filename_pattern", "{serial}_{profile}.pdf"))
        ttk.Entry(of, textvariable=self.fnp_var, width=48).grid(row=1, column=1, sticky="w", padx=(6, 12), pady=(8, 0))

        ttk.Label(of, text="Copies:").grid(row=2, column=0, sticky="w", pady=(8, 0))
        self.copies_var = tk.IntVar(value=int(self.profile.get("copies", 1)))
        ttk.Spinbox(of, from_=1, to=50, increment=1, textvariable=self.copies_var, width=6, justify="right").grid(row=2, column=1, sticky="w", padx=(6, 12), pady=(8, 0))

        self.open_after_var = tk.BooleanVar(value=bool(self.profile.get("open_after", True)))
        ttk.Checkbutton(of, text="Open after export", variable=self.open_after_var).grid(row=3, column=1, sticky="w", pady=(8, 0))

        ttk.Label(of, text="Output folder:").grid(row=4, column=0, sticky="w", pady=(8, 0))
        ttk.Entry(of, textvariable=self.outdir_var, width=54).grid(row=4, column=1, sticky="w", padx=(6, 12), pady=(8, 0))
        ttk.Button(of, text="Browse...", command=self._browse_outdir).grid(row=4, column=2, sticky="w", pady=(8, 0))

        # Traces and initial sync
        self._attach_profile_traces()
        self._sync_profile_to_ui()
        self._ensure_graph_ui_ready()
    
    # ========== Bindings tab ==========
    def _build_tab_bindings(self):
        tab = ttk.Frame(self.nb)
        self.nb.add(tab, text="Bindings")

        # Header (fixed, non-scrolling)
        self._make_profile_header(tab)

        sf = ScrollableFrame(tab)
        sf.pack(fill="both", expand=True, padx=6, pady=6)

        # Action row
        action_row = ttk.Frame(sf.scrollable_frame)
        action_row.pack(fill="x", padx=10, pady=(4, 2))
        ttk.Button(action_row, text="Save Bindings", command=self.on_save_bindings).pack(side="right")
        ttk.Label(action_row, text="(Pick flow columns and slot columns, then Save Bindings)").pack(side="right", padx=(0, 8))

        # Graph bindings
        self.bind_graph = ttk.LabelFrame(sf.scrollable_frame, text="Graph Bindings")
        self.bind_graph.pack(fill="x", padx=10, pady=6)

        self.bg_title_var = tk.StringVar(value=self.profile.get("bindings", {}).get("title", "Neb Label"))
        self.bg_inc_trend_var = tk.BooleanVar(value=bool(self.profile.get("bindings", {}).get("include_trendline", True)))
        ttk.Label(self.bind_graph, text="Title:").grid(row=0, column=0, sticky="w")
        ttk.Entry(self.bind_graph, textvariable=self.bg_title_var, width=36).grid(row=0, column=1, sticky="w", padx=(6, 12))
        ttk.Checkbutton(self.bind_graph, text="Include trendline", variable=self.bg_inc_trend_var).grid(row=0, column=2, sticky="w")

        ttk.Label(self.bind_graph, text="Flow columns (X):").grid(row=1, column=0, sticky="nw", pady=(8, 0))
        self.list_cols = tk.Listbox(self.bind_graph, selectmode="multiple", width=48, height=12, exportselection=False)
        try:
            self.list_cols.configure(selectbackground="#0E6CD6", selectforeground="white")
        except Exception:
            pass
        self.list_cols.grid(row=1, column=1, columnspan=3, sticky="w", padx=(6, 0), pady=(8, 0))

        # Right-side selected text panel (top-to-bottom)
        sel_panel = ttk.Frame(self.bind_graph)
        sel_panel.grid(row=1, column=4, sticky="nw", padx=(12, 0), pady=(8, 0))
        ttk.Label(sel_panel, text="Selected (top to bottom):").pack(anchor="w")
        self.selected_cols_text = tk.Text(sel_panel, width=28, height=12, wrap="none")
        self.selected_cols_text.configure(state="disabled")
        self.selected_cols_text.pack(fill="both", expand=False, pady=(4, 0))

        self.list_cols.bind("<<ListboxSelect>>", lambda e: (self._on_profile_field_change(), self._render_selected_cols_view()))

        # Graph: Value slots (optional) — dynamic count
        ttk.Label(self.bind_graph, text="Value Slots (optional):").grid(row=3, column=0, sticky="w", pady=(10, 2))
        self.g_slot_label_vars = []
        self.g_slot_col_vars = []
        self.g_slot_col_cbs = []

        slots_count = int(self.profile.get("template", {}).get("slots_count", 10))
        row = 4
        for i in range(1, slots_count + 1):
            labv = tk.StringVar()
            colv = tk.StringVar()
            self.g_slot_label_vars.append(labv)
            self.g_slot_col_vars.append(colv)
            ttk.Label(self.bind_graph, text=f"Label {i}:").grid(row=row, column=0, sticky="w")
            ent = ttk.Entry(self.bind_graph, textvariable=labv, width=24)
            ent.grid(row=row, column=1, sticky="w", padx=(6, 12))
            ent.bind("<FocusOut>", lambda e: self._on_profile_field_change())
            ttk.Label(self.bind_graph, text=f"Value {i} column:").grid(row=row, column=2, sticky="w")
            cb = ttk.Combobox(self.bind_graph, textvariable=colv, width=24, state="readonly")
            cb.grid(row=row, column=3, sticky="w", padx=(6, 12))
            cb.bind("<<ComboboxSelected>>", lambda e, idx=i: self._on_profile_field_change())
            self.g_slot_col_cbs.append(cb)
            row += 1

        # Value bindings (non-graph)
        self.bind_values = ttk.LabelFrame(sf.scrollable_frame, text="Value Bindings")
        self.bv_title_var = tk.StringVar()
        self.bv_subtitle_var = tk.StringVar()
        self.bv_logo_var = tk.StringVar()

        row = 0
        ttk.Label(self.bind_values, text="Title:").grid(row=row, column=0, sticky="w"); row += 1
        e = ttk.Entry(self.bind_values, textvariable=self.bv_title_var, width=36)
        e.grid(row=row-1, column=1, sticky="w", padx=(6, 12))
        e.bind("<FocusOut>", lambda ev: self._on_profile_field_change())

        ttk.Label(self.bind_values, text="Subtitle:").grid(row=row, column=0, sticky="w"); row += 1
        e2 = ttk.Entry(self.bind_values, textvariable=self.bv_subtitle_var, width=36)
        e2.grid(row=row-1, column=1, sticky="w", padx=(6, 12))
        e2.bind("<FocusOut>", lambda ev: self._on_profile_field_change())

        ttk.Label(self.bind_values, text="Logo path:").grid(row=row, column=0, sticky="w"); row += 1
        le = ttk.Entry(self.bind_values, textvariable=self.bv_logo_var, width=48)
        le.grid(row=row-1, column=1, sticky="w", padx=(6, 6))
        ttk.Button(self.bind_values, text="Browse...", command=self._browse_logo).grid(row=row-1, column=2, sticky="w")
        le.bind("<FocusOut>", lambda ev: self._on_profile_field_change())

        self.slot_label_vars = []
        self.slot_col_vars = []
        self.slot_col_cbs = []

        slots_count = int(self.profile.get("template", {}).get("slots_count", 10))
        for i in range(1, slots_count + 1):
            labv = tk.StringVar()
            colv = tk.StringVar()
            self.slot_label_vars.append(labv)
            self.slot_col_vars.append(colv)
            ttk.Label(self.bind_values, text=f"Label {i}:").grid(row=row, column=0, sticky="w")
            ent = ttk.Entry(self.bind_values, textvariable=labv, width=24)
            ent.grid(row=row, column=1, sticky="w", padx=(6, 12))
            ent.bind("<FocusOut>", lambda e: self._on_profile_field_change())
            ttk.Label(self.bind_values, text=f"Value {i} column:").grid(row=row, column=2, sticky="w")
            cb = ttk.Combobox(self.bind_values, textvariable=colv, width=24, state="readonly")
            cb.grid(row=row, column=3, sticky="w", padx=(6, 12))
            cb.bind("<<ComboboxSelected>>", lambda e, idx=i: self._on_profile_field_change())
            self.slot_col_cbs.append(cb)
            row += 1

        self._toggle_binding_panels()
        self._refresh_binding_columns()
        try:
            self._render_selected_cols_view()
        except Exception:
            pass
        
    def _ensure_graph_ui_ready(self):
        """
        Ensure the graph-related UI is fully initialized and interactive.
        Call after profiles/sheets load, when creating new profile, or when include_graph flips.
        """
        try:
            self._refresh_binding_columns()
        except Exception:
            pass
        try:
            self._toggle_binding_panels()
        except Exception:
            pass
        try:
            self._update_graph_controls_visibility()
        except Exception:
            pass
        try:
            if hasattr(self, "_render_selected_cols_view"):
                self._render_selected_cols_view()
        except Exception:
            pass
    
    def _match_serial_value(self, text: str, values: List[str]) -> Optional[str]:
        """
        Return the best matching serial from values for the typed text.
        Priority: exact match (case insensitive) > startswith (case insensitive) > contains.
        """
        if not text:
            return None
        t = text.strip().lower()
        if not t:
            return None
        # Exact
        for v in values:
            if v.lower() == t:
                return v
        # Startswith
        for v in values:
            if v.lower().startswith(t):
                return v
        # Contains
        for v in values:
            if t in v.lower():
                return v
        return None

    def _on_serial_typed_data(self, event=None):
        """
        Type-to-select for the Data Source tab serial combobox with true autocomplete.
        """
        try:
            values = list(self.serial_pick_menu["values"]) if hasattr(self, "serial_pick_menu") else []
            self._autocomplete_serial(self.serial_pick_menu, self.serial_pick_var, values, event, mirror_var=getattr(self, "profile_serial_pick_var", None))
        except Exception:
            pass

    def _on_serial_typed_profile(self, event=None):
        """
        Type-to-select for the Profile tab serial combobox with true autocomplete.
        """
        try:
            values = list(self.profile_serial_pick_menu["values"]) if hasattr(self, "profile_serial_pick_menu") else []
            self._autocomplete_serial(self.profile_serial_pick_menu, self.profile_serial_pick_var, values, event, mirror_var=getattr(self, "serial_pick_var", None))
        except Exception:
            pass

    def _commit_serial_selection(self, serial_value: str):
        """
        Commit the chosen serial across both tabs, select the row, and persist last_serial.
        """
        try:
            # Mirror into both combobox variables if present
            if hasattr(self, "serial_pick_var") and self.serial_pick_var is not None:
                self.serial_pick_var.set(serial_value)
            if hasattr(self, "profile_serial_pick_var") and self.profile_serial_pick_var is not None:
                self.profile_serial_pick_var.set(serial_value)

            # Select row in DataFrame (if possible)
            try:
                self._select_row_by_serial()
            except Exception:
                pass

            # Persist into profile
            try:
                self.profile.setdefault("data_source", {})["last_serial"] = serial_value
                save_profile(self.profile)
            except Exception:
                pass
            self._set_status(f"Serial selected: {serial_value}")
        except Exception:
            pass

    def _autocomplete_serial(self, combo: ttk.Combobox, var: tk.StringVar, values: List[str], event=None, mirror_var: Optional[tk.StringVar] = None):
        """
        Autocomplete behavior for a ttk.Combobox:
        - Live prefix match; falls back to contains if no prefix match.
        - Auto-fills with selected completion highlighted for continued typing.
        - Commit on Enter or exact match.
        """
        try:
            text = (var.get() or "")
            t = text.strip()
            vals = values or []
            if not t:
                return

            # Key handling: allow navigation keys to pass without changing content, but still
            # allow BackSpace/Delete to re-suggest based on the new typed prefix.
            nav_keys = {"Left", "Right", "Home", "End", "Prior", "Next"}  # page up/down, arrows
            commit_keys = {"Return", "KP_Enter"}
            if event is not None and event.keysym in nav_keys:
                return

            # Find best match: prefix first, then contains (case-insensitive)
            tl = t.lower()
            match = None

            # Prefix match
            for v in vals:
                if v.lower().startswith(tl):
                    match = v
                    break

            # Fallback to contains
            if not match:
                for v in vals:
                    if tl in v.lower():
                        match = v
                        break

            # If no match, do nothing further
            if not match:
                return

            # If Enter pressed or exact match typed, commit the selection
            if (event is not None and event.keysym in commit_keys) or (match.lower() == tl):
                self._commit_serial_selection(match)
                return

            # Otherwise, suggest by auto-filling and selecting the completion part
            combo.set(match)
            try:
                # Place cursor at end of the typed text; select the suggested tail
                combo.icursor(len(t))
                combo.selection_range(len(t), len(match))
            except Exception:
                pass

            # Do NOT commit yet; let the user continue typing or press Enter to commit
        except Exception:
            pass


    def _refresh_binding_columns(self):
        """
        Rebuild binding choices from self.df and re-apply saved selections.

        - Populates the Flow columns (X) listbox with current df columns.
        - Re-applies saved selections from profile['bindings']['x_flow_columns'].
        - Updates the right-side selected text panel.
        - Populates slot column comboboxes (graph and non-graph) with df columns,
        and re-applies saved selections that still exist.
        - Also re-applies the slot LABEL text into the entry fields so the user's
        typed labels remain visible after saving or toggling modes.
        - Adds an explicit '(none)' option for value-column comboboxes.
        - Defensive: safe if widgets or df are not yet available.
        """
        NONE_LABEL = "(none)"

        # 1) Collect column names from the loaded DataFrame
        try:
            cols = list(self.df.columns) if getattr(self, "df", None) is not None else []
        except Exception:
            cols = []
        cols_with_none = [NONE_LABEL] + cols

        # 2) Load saved bindings (defensive)
        try:
            b = self.profile.get("bindings", {}) if getattr(self, "profile", None) else {}
        except Exception:
            b = {}

        # 3) Flow columns listbox
        try:
            if hasattr(self, "list_cols") and self.list_cols is not None:
                # Refresh entries
                try:
                    self.list_cols.delete(0, tk.END)
                    for c in cols:
                        self.list_cols.insert(tk.END, c)
                except Exception:
                    pass

                # Re-apply saved selections (accept list or '|' separated string)
                saved = b.get("x_flow_columns", []) or []
                if isinstance(saved, str):
                    saved = [s.strip() for s in saved.split("|") if s.strip()]
                try:
                    self.list_cols.selection_clear(0, tk.END)
                except Exception:
                    pass

                try:
                    # Map saved names to current indices; ignore names not in current df
                    name_to_idx = {name: i for i, name in enumerate(cols)}
                    for name in saved:
                        idx = name_to_idx.get(name)
                        if idx is not None:
                            try:
                                self.list_cols.selection_set(idx)
                            except Exception:
                                pass
                except Exception:
                    pass
        except Exception:
            pass

        # 4) Graph slot combobox options and selections + label text (Value Slots under Graph Bindings)
        try:
            for cb in getattr(self, "g_slot_col_cbs", []) or []:
                try:
                    cb["values"] = cols_with_none
                except Exception:
                    pass

            # Determine how many graph slot rows we actually have in the UI (fixed 6 in this file)
            try:
                g_n = min(len(getattr(self, "g_slot_label_vars", []) or []),
                        len(getattr(self, "g_slot_col_vars", []) or []))
            except Exception:
                g_n = 0

            for i in range(g_n):
                idx = i + 1
                # Value column
                key_col = f"slot{idx}_col"
                val_col = (b.get(key_col, "") or "").strip()
                try:
                    if not val_col or val_col not in cols:
                        self.g_slot_col_vars[i].set(NONE_LABEL)
                    else:
                        self.g_slot_col_vars[i].set(val_col)
                except Exception:
                    pass

                # Label text
                key_lab = f"slot{idx}_label"
                val_lab = (b.get(key_lab, "") or "")
                try:
                    self.g_slot_label_vars[i].set(val_lab)
                except Exception:
                    pass
        except Exception:
            pass

        # 5) Non-graph (Value Bindings) slot combobox options/selections + label text
        try:
            for cb in getattr(self, "slot_col_cbs", []) or []:
                try:
                    cb["values"] = cols_with_none
                except Exception:
                    pass

            # Determine how many non-graph slot rows we have (fixed 6 in this file)
            try:
                n_n = min(len(getattr(self, "slot_label_vars", []) or []),
                        len(getattr(self, "slot_col_vars", []) or []))
            except Exception:
                n_n = 0

            for i in range(n_n):
                idx = i + 1
                # Value column
                key_col = f"slot{idx}_col"
                val_col = (b.get(key_col, "") or "").strip()
                try:
                    if not val_col or val_col not in cols:
                        self.slot_col_vars[i].set(NONE_LABEL)
                    else:
                        self.slot_col_vars[i].set(val_col)
                except Exception:
                    pass

                # Label text
                key_lab = f"slot{idx}_label"
                val_lab = (b.get(key_lab, "") or "")
                try:
                    self.slot_label_vars[i].set(val_lab)
                except Exception:
                    pass
        except Exception:
            pass

        # 6) Update the right-side selected view to match current listbox selection
        try:
            if hasattr(self, "_render_selected_cols_view"):
                self._render_selected_cols_view()
        except Exception:
            pass

        # 7) Reflect graph/value mode enable/disable states
        try:
            if hasattr(self, "_update_graph_controls_visibility"):
                self._update_graph_controls_visibility()
        except Exception:
            pass


    def _toggle_binding_panels(self):
        """
        Show/hide the correct bindings panel based on 'Include graph', and refresh
        controls so any saved labels/columns immediately populate the visible entries.
        """
        try:
            graph_mode = bool(self.include_graph_var.get())
        except Exception:
            graph_mode = False

        if graph_mode:
            if hasattr(self, "bind_values"):
                try: self.bind_values.pack_forget()
                except Exception: pass
            if hasattr(self, "bind_graph"):
                try: self.bind_graph.pack(fill="x", padx=10, pady=10)
                except Exception: pass
        else:
            if hasattr(self, "bind_graph"):
                try: self.bind_graph.pack_forget()
                except Exception: pass
            if hasattr(self, "bind_values"):
                try: self.bind_values.pack(fill="x", padx=10, pady=10)
                except Exception: pass

        # After switching panels, re-apply saved labels/columns into the now-visible entries
        try:
            self._refresh_binding_columns()
        except Exception:
            pass


    def on_save_bindings(self):
        """
        Save the current bindings (flow columns, slot labels/columns) to the active profile file.
        Shows a short confirmation, refreshes the selected columns view, and keeps the
        entry boxes populated with the saved values so the user sees their text stay.
        """
        try:
            # Ensure the latest UI selections are written into the profile dict
            self._on_profile_field_change(force_save=True)

            # Persist to disk
            save_profile(self.profile)

            # Re-apply bindings back into the UI so entries remain populated
            try:
                self._refresh_binding_columns()
            except Exception:
                pass

            # Refresh the visible right-side list
            try:
                if hasattr(self, "_render_selected_cols_view"):
                    self._render_selected_cols_view()
            except Exception:
                pass

            # Brief confirmation for the user
            try:
                self._flash_message("Bindings saved", 1500)
            except Exception:
                self._set_status("Bindings saved")
        except Exception as e:
            try:
                messagebox.showerror("Save Bindings", f"Failed to save bindings: {e}")
            except Exception:
                pass  
        
    # ========== Actions tab ==========
    def _build_tab_actions(self):
        tab = ttk.Frame(self.nb)
        self.nb.add(tab, text="Preview & Generate")

        # Header (fixed)
        self._make_profile_header(tab)

        f = ttk.Frame(tab); f.pack(fill="x", padx=10, pady=10)
        ttk.Button(f, text="Preview (current row)", command=self.on_preview).pack(side="left")
        ttk.Button(f, text="Generate PDF (current row)", command=self.on_generate).pack(side="left", padx=(10, 0))

    # ========== Debug helper ==========
    def _debug_print_profile_and_row(self, profile, df, row):
        try:
            import json, pprint
            print("---- DEBUG PROFILE ----")
            try:
                print(json.dumps(profile, indent=2, default=str)[:4000])
            except Exception:
                pprint.pprint(profile)
            print("---- DEBUG DF HEAD ----")
            try:
                print(df.head().to_string() if df is not None else "<df is None>")
            except Exception:
                print("<failed to print df head>")
            print("---- DEBUG ROW ----")
            try:
                print(row.to_dict() if row is not None else "<row is None>")
            except Exception:
                print("<failed to print row>")
            print("------------------------")
        except Exception:
            pass

    def _on_profile_tab_serial_selected(self):
        """
        Called when the serial is chosen from the Profile tab's Serial (row) combobox.
        Keeps the Data tab's serial selection in sync, selects the row, and persists last_serial.
        """
        try:
            s = (self.profile_serial_pick_var.get() or "").strip()
            if not s:
                return
            # mirror into Data Source tab serial picker if present
            if hasattr(self, "serial_pick_var") and self.serial_pick_var is not None:
                try:
                    self.serial_pick_var.set(s)
                except Exception:
                    pass
            # select row if possible (uses serial_pick_var and serial_col_var)
            try:
                self._select_row_by_serial()
            except Exception:
                pass
            # persist into profile
            self.profile.setdefault("data_source", {})["last_serial"] = s
            try:
                save_profile(self.profile)
            except Exception:
                pass
            self._set_status(f"Serial selected: {s}")
        except Exception:
            pass

    def _update_profile_serial_menu_values(self, serial_list: List[str]):
        """
        Update the Serial (row) combobox on the Profile tab with the provided values and select an appropriate default.
        """
        try:
            if not hasattr(self, "profile_serial_pick_menu") or self.profile_serial_pick_menu is None:
                return
            self.profile_serial_pick_menu["values"] = serial_list or []
            last = (self.profile.get("data_source", {}) or {}).get("last_serial")
            if last and last in (serial_list or []):
                self.profile_serial_pick_var.set(last)
            elif serial_list:
                # choose last available by default if nothing saved
                self.profile_serial_pick_var.set(serial_list[-1])
        except Exception:
            pass

    # ========== Profile/UI sync and autosave ==========
    def _attach_profile_traces(self):
        def _safe_add_trace(var, cb):
            try:
                if var is not None:
                    var.trace_add("write", cb)
            except Exception:
                pass

        _safe_add_trace(getattr(self, "profile_pick_var", None), lambda *a: None)
        # Update header immediately and autosave on name change
        _safe_add_trace(
            getattr(self, "profile_name_var", None),
            lambda *a: (self._update_profile_header(), self._schedule_autosave())
        )

        # Data-source fields
        _safe_add_trace(getattr(self, "xlsx_var", None), lambda *a: self._schedule_autosave())
        _safe_add_trace(getattr(self, "sheet_var", None), lambda *a: self._schedule_autosave())
        _safe_add_trace(getattr(self, "serial_col_var", None), lambda *a: self._schedule_autosave())

        # Template/layout
        _safe_add_trace(getattr(self, "title_color_var", None), lambda *a: self._schedule_autosave())
        _safe_add_trace(getattr(self, "text_scale_var", None), lambda *a: self._schedule_autosave())
        _safe_add_trace(getattr(self, "margin_var", None), lambda *a: self._schedule_autosave())
        _safe_add_trace(getattr(self, "win_var", None), lambda *a: self._schedule_autosave())
        _safe_add_trace(getattr(self, "hin_var", None), lambda *a: self._schedule_autosave())
        _safe_add_trace(getattr(self, "plotw_var", None), lambda *a: self._schedule_autosave())
        # NEW: graph line color
        _safe_add_trace(getattr(self, "graph_line_color_var", None), lambda *a: self._schedule_autosave())

        # Output
        _safe_add_trace(getattr(self, "target_var", None), lambda *a: self._schedule_autosave())
        _safe_add_trace(getattr(self, "fnp_var", None), lambda *a: self._schedule_autosave())
        _safe_add_trace(getattr(self, "copies_var", None), lambda *a: self._schedule_autosave())
        _safe_add_trace(getattr(self, "open_after_var", None), lambda *a: self._schedule_autosave())

        # Include graph toggling
        def _include_graph_cb(*_):
            try:
                self._toggle_binding_panels()
            except Exception:
                pass
            self._schedule_autosave()
        _safe_add_trace(getattr(self, "include_graph_var", None), _include_graph_cb)

        # Template text saves on focus-out
        try:
            if hasattr(self, "template_text") and getattr(self, "template_text") is not None:
                self.template_text.bind("<FocusOut>", lambda e: self._schedule_autosave())
        except Exception:
            pass

    def _update_selected_cols_label(self):
        """
        Update the 'Selected:' summary under the Flow columns listbox so the user
        always sees which columns are selected (even if the listbox isn't focused).
        """
        try:
            if not hasattr(self, "selected_cols_var"):
                return
            if hasattr(self, "list_cols") and self.list_cols is not None:
                sel = [self.list_cols.get(i) for i in self.list_cols.curselection()]
                self.selected_cols_var.set("Selected: " + (", ".join(sel) if sel else "(none)"))
        except Exception:
            # never raise from UI helper
            pass


    def _schedule_autosave(self, delay_ms: int = 400):
        # Debounce frequent edits
        try:
            if self._autosave_after_id:
                self.after_cancel(self._autosave_after_id)
        except Exception:
            pass
        self._autosave_after_id = self.after(delay_ms, lambda: self._on_profile_field_change())

    def _on_profile_field_change(self, force_save: bool = False):
        if not getattr(self, "profile", None):
            return

        # Profile name
        try:
            if getattr(self, "profile_name_var", None):
                self.profile["profile_name"] = self.profile_name_var.get().strip() or self.profile.get("profile_name")
        except Exception:
            pass

        # Template & layout
        self.profile.setdefault("template", {})
        try:
            # Read live UI state for include_graph to avoid stale profile reads
            self.profile["template"]["include_graph"] = bool(self.include_graph_var.get())
        except Exception:
            pass
        try:
            self.profile["template"]["graph_scale"] = float(self.graph_scale_var.get())
            self.profile["template"]["graph_x"] = float(self.graph_x_var.get())
            self.profile["template"]["graph_y"] = float(self.graph_y_var.get())
        except Exception:
            pass
        try:
            if getattr(self, "template_text", None):
                self.profile["template"]["template_text"] = self.template_text.get("1.0", "end").rstrip("\n")
        except Exception:
            pass

        # Colors and sizing
        try:
            self.profile["title_color"] = self.title_color_var.get().strip() or DEFAULT_TITLE_COLOR
            # NEW: graph line color
            if hasattr(self, "graph_line_color_var"):
                self.profile["graph_line_color"] = (self.graph_line_color_var.get() or "").strip() or "#1F77B4"
            self.profile["text_scale_pct"] = int(self.text_scale_var.get())
            self.profile["margin_pct"] = int(self.margin_var.get())
            self.profile["label_w_in"] = float(self.win_var.get())
            self.profile["label_h_in"] = float(self.hin_var.get())
            self.profile["plot_width_pct"] = int(self.plotw_var.get())
        except Exception:
            pass

        # Output
        try:
            self.profile["output_target"] = self.target_var.get()
            self.profile["filename_pattern"] = self.fnp_var.get().strip() or "{serial}_{profile}.pdf"
            self.profile["copies"] = int(self.copies_var.get())
            self.profile["open_after"] = bool(self.open_after_var.get())
        except Exception:
            pass

        # Bindings save handled elsewhere when you click Save Bindings; still keep ds metadata
        ds = self.profile.setdefault("data_source", {})
        try:
            if getattr(self, "xlsx_var", None) and self.xlsx_var.get():
                ds["xlsx_path"] = self.xlsx_var.get()
            if getattr(self, "sheet_var", None) and self.sheet_var.get():
                ds["sheet"] = self.sheet_var.get()
            if getattr(self, "serial_col_var", None) and self.serial_col_var.get():
                ds["serial_col"] = self.serial_col_var.get()
        except Exception:
            pass

        # Save
        try:
            save_profile(self.profile)
        except Exception:
            pass



    def _browse_logo(self):
        try:
            path = filedialog.askopenfilename(
                title="Select Logo image",
                filetypes=[("Images", "*.png *.jpg *.jpeg *.bmp *.gif"), ("All files", "*.*")]
            )
            if not path:
                return
            if not getattr(self, "bv_logo_var", None):
                self.bv_logo_var = tk.StringVar()
            self.bv_logo_var.set(path)
            self._on_profile_field_change()
            self._set_status(f"Logo selected: {path}")
        except Exception as e:
            try:
                messagebox.showerror("Error", f"Failed to select logo: {e}")
            except Exception:
                pass

    def _get_font_families(self):
        """Return a sorted list of installed font family names for dropdowns."""
        try:
            import tkinter.font as tkfont
            fams = sorted(set(tkfont.families()))
            self._font_families = fams
            return fams
        except Exception:
            fams = ["Helvetica", "Times New Roman", "Courier New", "Arial"]
            self._font_families = fams
            return fams

    def _choose_color(self, target_var: tk.StringVar):
        """
        Open a color picker and set the chosen hex code into target_var.
        """
        try:
            from tkinter import colorchooser
            initial = (target_var.get() or "").strip() or "#000000"
            _rgb, hx = colorchooser.askcolor(title="Pick a color", initialcolor=initial)
            if hx:
                target_var.set(hx)
                try:
                    self._schedule_autosave()
                except Exception:
                    pass
        except Exception:
            pass

    def _browse_logo_template(self):
        """Browse for a template logo image path."""
        try:
            path = filedialog.askopenfilename(
                title="Select Logo image",
                filetypes=[("Images", "*.png *.jpg *.jpeg *.bmp *.gif"), ("All files", "*.*")]
            )
            if not path:
                return
            if not getattr(self, "tpl_logo_path_var", None):
                self.tpl_logo_path_var = tk.StringVar()
            self.tpl_logo_path_var.set(path)
            try:
                if hasattr(self, "tpl_logo_enabled_var"):
                    self.tpl_logo_enabled_var.set(True)
            except Exception:
                pass
            try:
                self._on_profile_field_change()
                self._set_status(f"Template logo: {path}")
            except Exception:
                pass
        except Exception as e:
            try:
                messagebox.showerror("Logo", f"Failed to select logo: {e}")
            except Exception:
                pass  

    def _sync_profile_to_ui(self):
        if getattr(self, "profile_name_var", None):
            self.profile_name_var.set(self.profile.get("profile_name", self.profile_name_var.get()))

        # Data source
        ds = self.profile.get("data_source", {}) or {}
        if getattr(self, "xlsx_var", None):
            if ds.get("xlsx_path"):
                try:
                    self.xlsx_var.set(ds.get("xlsx_path"))
                    self.xlsx_path = ds.get("xlsx_path")
                except Exception:
                    pass
            if getattr(self, "sheet_menu", None):
                try:
                    sheets = read_excel_sheet_names(ds.get("xlsx_path")) if ds.get("xlsx_path") else []
                    self.sheet_menu["values"] = sheets
                    if ds.get("sheet") and ds.get("sheet") in sheets:
                        self.sheet_var.set(ds.get("sheet"))
                        try: self._load_sheet()
                        except Exception: pass
                except Exception:
                    pass
            if getattr(self, "serial_col_var", None):
                try:
                    self.serial_col_var.set(ds.get("serial_col", self.serial_col_var.get()))
                except Exception:
                    pass
            try:
                if hasattr(self, "profile_serial_pick_var", None):
                    last = ds.get("last_serial")
                    if last:
                        self.profile_serial_pick_var.set(last)
            except Exception:
                pass

        # Template & layout
        tpl = self.profile.get("template", {})
        try: self.include_graph_var.set(bool(tpl.get("include_graph", False)))
        except Exception: pass
        try: self.graph_scale_var.set(float(tpl.get("graph_scale", 1.0)))
        except Exception: pass
        try: self.graph_x_var.set(float(tpl.get("graph_x", 0.0)))
        except Exception: pass
        try: self.graph_y_var.set(float(tpl.get("graph_y", 0.0)))
        except Exception: pass

        # Colors and sizing
        try: self.title_color_var.set(self.profile.get("title_color", DEFAULT_TITLE_COLOR))
        except Exception: pass
        try:
            if hasattr(self, "graph_line_color_var"):
                self.graph_line_color_var.set(self.profile.get("graph_line_color", "#1F77B4"))
        except Exception:
            pass
        try: self.text_scale_var.set(int(self.profile.get("text_scale_pct", DEFAULT_TEXT_SCALE_PCT)))
        except Exception: pass
        try: self.margin_var.set(int(self.profile.get("margin_pct", DEFAULT_MARGIN_PCT)))
        except Exception: pass
        try: self.win_var.set(str(self.profile.get("label_w_in", 3.0)))
        except Exception: pass
        try: self.hin_var.set(str(self.profile.get("label_h_in", 4.0)))
        except Exception: pass
        try: self.plotw_var.set(int(self.profile.get("plot_width_pct", DEFAULT_PLOT_WIDTH_PCT)))
        except Exception: pass

        # Template text
        if getattr(self, "template_text", None):
            try:
                self.template_text.delete("1.0", "end")
                self.template_text.insert("1.0", tpl.get("template_text", ""))
            except Exception:
                pass

        # Output
        try: self.target_var.set(self.profile.get("output_target", TARGET_LX900_3x4))
        except Exception: pass
        try: self.fnp_var.set(self.profile.get("filename_pattern", "{serial}_{profile}.pdf"))
        except Exception: pass
        try: self.copies_var.set(int(self.profile.get("copies", 1)))
        except Exception: pass
        try: self.open_after_var.set(bool(self.profile.get("open_after", True)))
        except Exception: pass
        try:
            if not self.outdir_var.get():
                self.outdir_var.set(str(Path.cwd()))
        except Exception:
            pass

        # Keep bindings panel states sane
        try: self._refresh_binding_columns()
        except Exception: pass
        try: self._toggle_binding_panels()
        except Exception: pass
        try: self._update_graph_controls_visibility()
        except Exception: pass

        # Update profile headers on every sync
        try:
            self._update_profile_header()
        except Exception:
            pass

    def _sync_ui_to_profile(self):
        self._on_profile_field_change()

    def _update_graph_controls_visibility(self):
        try:
            graph_mode = bool(self.include_graph_var.get())
        except Exception:
            graph_mode = False

        try:
            self.plotw_spin.configure(state="normal" if graph_mode else "disabled")
        except Exception:
            pass
        try:
            if hasattr(self, "list_cols") and self.list_cols is not None:
                self.list_cols.configure(state="normal" if graph_mode else "disabled")
        except Exception:
            pass
        for cb in getattr(self, "g_slot_col_cbs", []):
            try: cb.configure(state="readonly" if graph_mode else "disabled")
            except Exception: pass
        for cb in getattr(self, "slot_col_cbs", []):
            try: cb.configure(state="readonly" if not graph_mode else "disabled")
            except Exception: pass

    # ========== Actions & rendering ==========
    def _get_selected_row(self) -> Optional[pd.Series]:
        if self.df is None or self.current_row_index is None:
            return None
        try:
            return self.df.loc[self.current_row_index]
        except Exception:
            return None

    def _get_output_dir(self) -> Path:
        try:
            val = self.outdir_var.get().strip() if hasattr(self, "outdir_var") and self.outdir_var is not None else ""
            return Path(val) if val else Path.cwd()
        except Exception:
            return Path.cwd()

    def on_preview(self):
        row = self._get_selected_row()
        if row is None:
            messagebox.showerror("Preview", "Select a data row first.")
            return
        try: self._sync_ui_to_profile()
        except Exception: pass

        out_dir = self._get_output_dir()
        out_dir.mkdir(parents=True, exist_ok=True)
        tmp_pdf = out_dir / "_preview_label.pdf"

        try:
            render_profile_to_pdf(self.profile, self.df, row, tmp_pdf)
            if not tmp_pdf.exists() or tmp_pdf.stat().st_size == 0:
                messagebox.showerror("Preview failed", f"Output file missing or empty: {tmp_pdf}")
                self._set_status("Preview failed: output missing")
                return
            self.last_pdf = tmp_pdf
            try: self._open_file(tmp_pdf)
            except Exception: pass
            self._set_status(f"Preview generated: {tmp_pdf}")
        except Exception as e:
            import traceback
            tb = traceback.format_exc()
            try: messagebox.showerror("Preview failed", f"{e}\n\n{tb}")
            except Exception:
                print("Preview failed:", e); print(tb)
            self._set_status("Preview failed: see console")

    def on_generate(self):
        row = self._get_selected_row()
        if row is None:
            messagebox.showerror("Generate", "Select a data row first.")
            return
        try: self._sync_ui_to_profile()
        except Exception: pass

        serial_col = self.serial_col_var.get() if hasattr(self, "serial_col_var") else ""
        serial_val = str(row.get(serial_col, "")).strip() if serial_col else ""
        filename = self.profile.get("filename_pattern", "{serial}_{profile}.pdf")
        filename = filename.replace("{serial}", serial_val or "row")
        filename = filename.replace("{profile}", self.profile.get("profile_name", "Profile"))

        out_dir = self._get_output_dir()
        out_dir.mkdir(parents=True, exist_ok=True)
        out_pdf = out_dir / filename

        try:
            render_profile_to_pdf(self.profile, self.df, row, out_pdf)
            if not out_pdf.exists() or out_pdf.stat().st_size == 0:
                messagebox.showerror("Generate failed", f"Output file missing or empty: {out_pdf}")
                self._set_status("Generate failed: output missing")
                return
            self.last_pdf = out_pdf
            open_after = False
            try: open_after = bool(self.open_after_var.get())
            except Exception: pass
            if open_after:
                try: self._open_file(out_pdf)
                except Exception: pass
            self._set_status(f"PDF generated: {out_pdf}")
        except Exception as e:
            import traceback
            tb = traceback.format_exc()
            try: messagebox.showerror("Generate failed", f"{e}\n\n{tb}")
            except Exception:
                print("Generate failed:", e); print(tb)
            self._set_status("Generate failed: see console")

    def _open_file(self, path: Path):
        try:
            if sys.platform.startswith("win"):
                os.startfile(str(path))  # type: ignore[attr-defined>
            elif sys.platform == "darwin":
                os.system(f"open '{path}'")
            else:
                os.system(f"xdg-open '{path}'")
        except Exception:
            pass

    # ========== Utilities: profile lifecycle ==========
    def _refresh_profile_list(self):
        names = list_profiles()
        self.profile_pick_menu["values"] = names
        if self.profile.get("profile_name") and self.profile.get("profile_name") in names:
            self.profile_pick_var.set(self.profile.get("profile_name"))

    def _load_selected_profile(self):
        name = self.profile_pick_var.get().strip()
        if not name:
            return
        try:
            self.profile = load_profile(name)
            if "template" not in self.profile:
                self.profile["template"] = {}
            self.profile_name_var.set(self.profile.get("profile_name", name))

            # Sync all UI from profile (this loads sheet if present)
            self._sync_profile_to_ui()

            # Make sure Bindings tab widgets are correctly enabled/disabled and populated
            self._ensure_graph_ui_ready()

            # Update header text
            try:
                self._update_profile_header()
            except Exception:
                pass

            self._set_status(f"Profile loaded: {name}")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to load profile: {e}")

    def _new_profile(self):
        """
        Create a fresh profile using the default template settings.
        Keeps current Data Source selections (xlsx/sheet/serial) so you don't have to re-pick.
        Ensures graph bindings are enabled and selectable immediately.
        """
        try:
            # Start with a fresh profile model
            new_prof = default_profile(TEMPLATE_GRAPH)

            # Optionally carry over current output settings and filename pattern
            try:
                new_prof["output_target"] = self.profile.get("output_target", new_prof.get("output_target"))
                new_prof["filename_pattern"] = self.profile.get("filename_pattern", new_prof.get("filename_pattern", "{serial}_{profile}.pdf"))
                new_prof["copies"] = self.profile.get("copies", new_prof.get("copies", 1))
                new_prof["open_after"] = self.profile.get("open_after", new_prof.get("open_after", True))
            except Exception:
                pass

            # Keep current Data Source selection (if present) to avoid re-picking
            ds = {}
            try:
                if hasattr(self, "xlsx_var") and self.xlsx_var.get():
                    ds["xlsx_path"] = self.xlsx_var.get()
                if hasattr(self, "sheet_var") and self.sheet_var.get():
                    ds["sheet"] = self.sheet_var.get()
                if hasattr(self, "serial_col_var") and self.serial_col_var.get():
                    ds["serial_col"] = self.serial_col_var.get()
                if hasattr(self, "serial_pick_var") and self.serial_pick_var.get():
                    ds["last_serial"] = self.serial_pick_var.get()
            except Exception:
                pass
            if ds:
                new_prof["data_source"] = ds

            # Swap in and refresh UI
            self.profile = new_prof
            try:
                self.profile_name_var.set(self.profile.get("profile_name", "Profile"))
            except Exception:
                pass

            # Force Include Graph ON for new graph profile so widgets aren't greyed out
            try:
                self.include_graph_var.set(True)
                self.profile.setdefault("template", {})["include_graph"] = True
            except Exception:
                pass

            # Re-apply to UI and make graph UI ready
            self._sync_profile_to_ui()
            self._ensure_graph_ui_ready()

            # Don’t save automatically; user can Save or Save As to name it
            self._set_status(f"New profile created: {self.profile.get('profile_name', 'Profile')}")
        except Exception as e:
            messagebox.showerror("New Profile", f"Failed to create new profile: {e}")

    def on_save_profile(self):
        self._sync_ui_to_profile()
        p = save_profile(self.profile)
        self._refresh_profile_list()
        self._set_status(f"Profile saved: {p}")

    def on_save_as_profile(self):
        self._sync_ui_to_profile()
        name = self._prompt_text("Save Profile As", "Profile name:", default=self.profile.get("profile_name", "Profile"))
        if not name:
            return
        self.profile["profile_name"] = name
        p = save_profile(self.profile)
        self._refresh_profile_list()
        self.profile_pick_var.set(self.profile["profile_name"])
        self._set_status(f"Profile saved as: {p}")

    def on_delete_profile(self):
        name = self.profile_pick_var.get().strip()
        if not name:
            messagebox.showinfo("Delete", "Select a profile to delete.")
            return
        if not messagebox.askyesno("Delete", f"Delete profile '{name}'?"):
            return
        try:
            pp = PROFILE_DIR / f"{name}.json"
            if pp.exists():
                pp.unlink()
            self._refresh_profile_list()
            self._set_status(f"Deleted profile: {name}")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to delete: {e}")

    def _browse_outdir(self):
        path = filedialog.askdirectory(title="Select output folder")
        if path:
            self.outdir_var.set(path)
            self._schedule_autosave()

    def _flash_message(self, msg: str, ms: int = 1200):
        try:
            self._set_status(msg)
            if getattr(self, "_flash_after_id", None):
                try: self.after_cancel(self._flash_after_id)
                except Exception: pass
            def _clear():
                try: self._set_status("")
                except Exception: pass
            self._flash_after_id = self.after(ms, _clear)
        except Exception:
            pass

    def _prompt_text(self, title: str, prompt: str, default: str = "") -> Optional[str]:
        win = tk.Toplevel(self); win.title(title)
        ttk.Label(win, text=prompt).pack(side="top", anchor="w", padx=10, pady=(10, 4))
        var = tk.StringVar(value=default)
        ent = ttk.Entry(win, textvariable=var, width=40); ent.pack(side="top", padx=10, pady=(0, 10))
        out = {"ok": False}
        def ok(): out["ok"] = True; win.destroy()
        def cancel(): win.destroy()
        btns = ttk.Frame(win); btns.pack(side="top", padx=10, pady=(0, 10))
        ttk.Button(btns, text="OK", command=ok).pack(side="left", padx=(0, 8))
        ttk.Button(btns, text="Cancel", command=cancel).pack(side="left")
        ent.focus_set(); win.grab_set(); self.wait_window(win)
        return var.get().strip() if out["ok"] else None

    def _set_status(self, msg: str):
        self.status_var.set(msg)
        self.update_idletasks()

    def on_close(self):
        try:
            self._sync_ui_to_profile()
            save_profile(self.profile)
        except Exception:
            pass
        self.master.destroy()

def main():
    root = tk.Tk()
    try:
        if sys.platform.startswith("win"):
            root.tk.call('tk', 'scaling', 1.25)
    except Exception:
        pass
    app = App(root)
    root.minsize(980, 720)
    root.mainloop()

if __name__ == "__main__":
    main()
